# 実装要素一覧

GEasy-Kitライブラリで実装する要素をまとめたドキュメント

> **📖 関連ドキュメント**
> - 詳細な実装仕様は [サービス設計.md](./サービス設計.md) を参照
> - Core Engineの仕様は [コアエンジン.md](./コアエンジン.md) を参照
> - 各機能の個別ドキュメントは [features/](./features/) ディレクトリを参照

## このライブラリが目指すもの

> **JRPGにおける「戦闘・成長・管理・敵行動」のよくある操作フローを、UIや世界に依存しない Service 群として提供する**

このライブラリは「プレイヤーと敵を含むJRPGの操作フロー」を再利用可能な Service 群として提供するための基盤です。

## スコープ

### ❌ 扱わないもの
- 世界・マップ・シナリオ
- 会話・演出・カメラ
- 描画・アニメーション・サウンド
- 座標・物理・移動

### ✅ 扱うもの
- プレイヤーキャラと敵の数値・状態
- 戦闘とその前後の流れ
- 成長・装備・クラフト
- JRPG特有の操作体験
- 状態管理と永続化

## 全体アーキテクチャ

```text
UI（見た目・入力）
  ↓
Headless UI（選択・確認・キャンセル）
  ↓
JRPG Services（操作フロー）
  ↓
Core Engine（数値・ルール）
  ↓
Game State（永続可能な状態）
```

## Service 共通の性質

すべての Service は以下の特性を持ちます：

- **複数ステップの進行を持つ**: 戦闘開始→コマンド選択→実行→結果のような流れ
- **状態を持ち、中断・再開できる**: セーブ/ロード対応
- **UIに依存しない**: Headless UI から操作される
- **数値計算やルールは持たない**: Core Engine に委譲
- **操作フローの管理に特化**: 選択肢の提示、決定、キャンセルの流れを管理

## 目次

### 🎮 戦闘・操作に関する機能
1. [戦闘](./features/戦闘.md) - 戦闘全体の進行とコマンド選択
2. [アイテム](./features/アイテム.md) - アイテム使用の流れ

### 🧠 敵に関する機能
3. [敵AI](./features/敵AI.md) - 敵の行動決定とグループ管理

### 📈 成長・キャラクターに関する機能
4. [キャラクター成長](./features/キャラクター成長.md) - 経験値とレベルアップ
5. [スキル習得](./features/スキル習得.md) - スキル習得の流れ
6. [ジョブ変更](./features/ジョブ変更.md) - 職業・クラス変更
7. [報酬](./features/報酬.md) - 戦闘やイベントの報酬処理

### 🎒 管理・編成に関する機能
8. [インベントリ](./features/インベントリ.md) - アイテムとバッグの管理
9. [装備](./features/装備.md) - 装備の変更管理
10. [パーティ編成](./features/パーティ編成.md) - パーティ編成管理
11. [状態異常](./features/状態異常.md) - 状態異常・バフ・デバフ管理

### 🛠 クラフト・育成に関する機能
12. [クラフト](./features/クラフト.md) - アイテム合成の流れ
13. [強化](./features/強化.md) - 装備やキャラクターの強化

### 💾 システム・支援に関する機能
14. [セーブロード](./features/セーブロード.md) - セーブとロードの流れ
15. [データ永続化](./features/データ永続化.md) - ゲーム状態の永続化
16. [シミュレーション](./features/シミュレーション.md) - 戦闘や成長のシミュレーション

---

## 各機能の詳細

各機能の詳細な仕様（操作フロー、状態管理、Core Engine委譲など）については、以下のドキュメントを参照してください：

- **Service層の詳細設計** - [サービス設計.md](./サービス設計.md)
  - 16のServiceの詳細な実装仕様
  - インターフェース定義
  - 実装例とコードサンプル

- **各機能の個別ドキュメント** - [features/](./features/) ディレクトリ
  - 機能ごとの詳細な説明
  - 使用例とユースケース
  - テスト観点

---

## 実装優先度

### フェーズ1：戦闘の基礎
1. 戦闘全体の進行を管理する Service
2. 戦闘中のコマンド選択を扱う Service
3. 敵の行動を自動決定する Service
4. 複数の敵をひとまとまりとして扱う Service

### フェーズ2：成長と管理
1. 戦闘やイベントの報酬を処理する Service
2. 装備の変更を管理する Service
3. パーティ編成を管理する Service
4. 状態異常やバフ・デバフを管理する Service

### フェーズ3：発展的な機能
1. スキル習得の流れを管理する Service
2. 職業・クラス変更の流れを管理する Service
3. アイテム使用の流れを扱う Service

### フェーズ4：拡張機能
1. アイテム合成の流れを管理する Service
2. 装備やキャラクターの強化を管理する Service
3. セーブとロードの流れを管理する Service
4. 戦闘や成長のシミュレーションを行う Service

---

## 技術的考慮事項

### Service の設計原則
- **ステートマシンパターン**: 各 Service は複数の状態を持ち、状態遷移を管理
- **イベント駆動**: Core Engine からのイベントを受け取り、UI へ通知
- **永続化対応**: すべての Service の状態はシリアライズ可能
- **UIフリー**: 具体的な UI 実装に依存しない抽象的なインターフェース

### Core Engine との分離
- Service は「いつ・何を・どの順で」を管理
- Core Engine は「どのように計算するか」を担当
- Service から Core Engine への呼び出しは明確なインターフェースを通じて行う

### 状態管理
- 各 Service は独立した状態を持つ
- Game State は全 Service の状態を統合
- セーブデータは Game State のスナップショット

### テスト容易性
- UI を使わず Service のみでテスト可能
- モック Core Engine を使った単体テスト
- 統合テストでの操作フローの検証

---

## まとめ

このライブラリは、JRPGの操作フローを再利用可能な Service として提供します。

### 設計の核心
- **操作フロー重視**: 数値計算ではなく、選択→確認→実行の流れを管理
- **段階的な進行**: すべての操作は複数ステップで構成され、中断・再開が可能
- **UI非依存**: Headless UI を介して任意の UI から操作可能
- **永続化対応**: すべての状態はセーブ・ロード可能

### 利用イメージ
開発者はこれらの Service を組み合わせることで、JRPG特有の操作体験を素早く実装できます。
- Web UI、コンソール UI、モバイル UI など、どの UI からでも同じ Service を利用可能
- テストやシミュレーションもUI なしで実行可能
- ゲーム固有のルールは Core Engine をカスタマイズすることで実現

実装は優先度に従って段階的に進め、各フェーズで動作確認を行うことを推奨します。
