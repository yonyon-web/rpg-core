# Service è©³ç´°è¨­è¨ˆ

GEasy-Kitãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®15ã®Serviceã«ã¤ã„ã¦ã€è©³ç´°ãªè¨­è¨ˆä»•æ§˜ã‚’ã¾ã¨ã‚ãŸãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

> **ğŸ“– ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®å½¹å‰²åˆ†æ‹…**
> - **ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: Serviceå±¤ã®è©³ç´°ãªå®Ÿè£…ä»•æ§˜ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã€å®Ÿè£…ä¾‹ã€Core Engineå§”è­²ï¼‰
> - **[å®Ÿè£…è¦ç´ .md](./å®Ÿè£…è¦ç´ .md)**: ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå…¨ä½“ã®æ¦‚è¦ã¨ç›®æŒ‡ã™ã‚‚ã®
> - **[ã‚³ã‚¢ã‚¨ãƒ³ã‚¸ãƒ³.md](./ã‚³ã‚¢ã‚¨ãƒ³ã‚¸ãƒ³.md)**: Core Engineã®å®Œå…¨ã‚¬ã‚¤ãƒ‰
> - **[features/](./features/)**: å„æ©Ÿèƒ½ã®å€‹åˆ¥ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

## è¨­è¨ˆæ–¹é‡

### Service ã®åŸºæœ¬åŸå‰‡

1. **ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«**: Serviceã¯æ“ä½œãƒ•ãƒ­ãƒ¼ã®çŠ¶æ…‹ã‚’ä¿æŒ
2. **UIãƒ•ãƒªãƒ¼**: è¡¨ç¤ºã‚„å…¥åŠ›å‡¦ç†ã«ä¾å­˜ã—ãªã„
3. **Core Engineå§”è­²**: è¨ˆç®—ã¨ãƒ«ãƒ¼ãƒ«åˆ¤å®šã¯Core Engineã«å§”è­²
4. **ä¸­æ–­ãƒ»å†é–‹å¯èƒ½**: ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰å¯¾å¿œã®ãŸã‚ã€çŠ¶æ…‹ã‚’æ°¸ç¶šåŒ–å¯èƒ½
5. **å‹å®‰å…¨**: TypeScriptã®å‹ã‚·ã‚¹ãƒ†ãƒ ã‚’æ´»ç”¨

### Service ã®è²¬ä»»ç¯„å›²

- âœ… æ“ä½œãƒ•ãƒ­ãƒ¼ã®ç®¡ç†ï¼ˆã„ã¤ã€ä½•ã‚’ã€ã©ã®é †ã§ï¼‰
- âœ… çŠ¶æ…‹ã®ä¿æŒã¨æ›´æ–°
- âœ… é¸æŠè‚¢ã®æç¤ºã¨æ±ºå®šã®å—ä»˜
- âœ… Core Engineã¸ã®è¨ˆç®—ä¾é ¼
- âœ… çµæœã®æ•´å½¢ã¨è¿”å´
- âŒ æ•°å€¤è¨ˆç®—ã‚„ãƒ«ãƒ¼ãƒ«åˆ¤å®šï¼ˆCore Engineã®è²¬ä»»ï¼‰
- âŒ UIæç”»ã‚„å…¥åŠ›å‡¦ç†ï¼ˆUIãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è²¬ä»»ï¼‰

---

## ç›®æ¬¡

### ğŸ® æˆ¦é—˜ãƒ»æ“ä½œã«é–¢ã™ã‚‹Service
1. [BattleService - æˆ¦é—˜å…¨ä½“ã®é€²è¡Œç®¡ç†](#1-battleservice---æˆ¦é—˜å…¨ä½“ã®é€²è¡Œç®¡ç†)
2. [CommandService - æˆ¦é—˜ä¸­ã®ã‚³ãƒãƒ³ãƒ‰é¸æŠ](#2-commandservice---æˆ¦é—˜ä¸­ã®ã‚³ãƒãƒ³ãƒ‰é¸æŠ)
3. [ItemService - ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨ã®æµã‚Œ](#3-itemservice---ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨ã®æµã‚Œ)

### ğŸ§  æ•µã«é–¢ã™ã‚‹Service
4. [EnemyAIService - æ•µã®è¡Œå‹•è‡ªå‹•æ±ºå®š](#4-enemyaiservice---æ•µã®è¡Œå‹•è‡ªå‹•æ±ºå®š)
5. [EnemyGroupService - æ•µã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç†](#5-enemygroupservice---æ•µã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç†)

### ğŸ“ˆ æˆé•·ãƒ»ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã«é–¢ã™ã‚‹Service
6. [SkillLearnService - ã‚¹ã‚­ãƒ«ç¿’å¾—ç®¡ç†](#6-skilllearnservice---ã‚¹ã‚­ãƒ«ç¿’å¾—ç®¡ç†)
7. [JobChangeService - è·æ¥­ãƒ»ã‚¯ãƒ©ã‚¹å¤‰æ›´](#7-jobchangeservice---è·æ¥­ã‚¯ãƒ©ã‚¹å¤‰æ›´)
8. [RewardService - æˆ¦é—˜å ±é…¬å‡¦ç†](#8-rewardservice---æˆ¦é—˜å ±é…¬å‡¦ç†)

### ğŸ’ ç®¡ç†ãƒ»ç·¨æˆã«é–¢ã™ã‚‹Service
9. [InventoryService - ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒª/ãƒãƒƒã‚°ç®¡ç†](#9-inventoryservice---ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãƒãƒƒã‚°ç®¡ç†)
10. [EquipmentService - è£…å‚™å¤‰æ›´ç®¡ç†](#10-equipmentservice---è£…å‚™å¤‰æ›´ç®¡ç†)
11. [PartyService - ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆç®¡ç†](#11-partyservice---ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆç®¡ç†)
12. [StatusEffectService - çŠ¶æ…‹ç•°å¸¸ãƒ»ãƒãƒ•ç®¡ç†](#12-statuseffectservice---çŠ¶æ…‹ç•°å¸¸ãƒãƒ•ç®¡ç†)

### ğŸ›  ã‚¯ãƒ©ãƒ•ãƒˆãƒ»è‚²æˆã«é–¢ã™ã‚‹Service
13. [CraftService - ã‚¢ã‚¤ãƒ†ãƒ åˆæˆç®¡ç†](#13-craftservice---ã‚¢ã‚¤ãƒ†ãƒ åˆæˆç®¡ç†)
14. [EnhanceService - è£…å‚™ãƒ»ã‚­ãƒ£ãƒ©å¼·åŒ–](#14-enhanceservice---è£…å‚™ã‚­ãƒ£ãƒ©å¼·åŒ–)

### ğŸ’¾ ã‚·ã‚¹ãƒ†ãƒ ãƒ»æ”¯æ´ã«é–¢ã™ã‚‹Service
15. [SaveLoadService - ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰ç®¡ç†](#15-saveloadservice---ã‚»ãƒ¼ãƒ–ãƒ­ãƒ¼ãƒ‰ç®¡ç†)
16. [SimulationService - æˆ¦é—˜ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³](#16-simulationservice---æˆ¦é—˜ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³)

---

## 1. BattleService - æˆ¦é—˜å…¨ä½“ã®é€²è¡Œç®¡ç†

### æ¦‚è¦
æˆ¦é—˜é–‹å§‹ã‹ã‚‰çµ‚äº†ã¾ã§ã®å…¨ä½“ãƒ•ãƒ­ãƒ¼ã‚’ç®¡ç†ã—ã€ã‚¿ãƒ¼ãƒ³é€²è¡Œã€ãƒ•ã‚§ãƒ¼ã‚ºåˆ‡ã‚Šæ›¿ãˆã€å‹æ•—åˆ¤å®šã‚’è¡Œã†ã€‚

### çŠ¶æ…‹ç®¡ç†

```typescript
interface BattleState {
  // æˆ¦é—˜çŠ¶æ…‹
  phase: 'initializing' | 'player-turn' | 'enemy-turn' | 'processing' | 'ended';
  turnNumber: number;
  
  // å‚åŠ è€…
  playerParty: Character[];
  enemyGroup: Enemy[];
  
  // è¡Œå‹•é †
  turnOrder: Combatant[];
  currentActorIndex: number;
  
  // æˆ¦é—˜çµæœ
  result?: 'victory' | 'defeat' | 'escaped';
  rewards?: BattleRewards;
  
  // å±¥æ­´
  actionHistory: BattleAction[];
}
```

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class BattleService {
  // æˆ¦é—˜é–‹å§‹
  startBattle(party: Character[], enemies: Enemy[]): Promise<void>;
  
  // ã‚¿ãƒ¼ãƒ³é€²è¡Œ
  advanceTurn(): Promise<void>;
  
  // è¡Œå‹•å®Ÿè¡Œ
  executeAction(actor: Combatant, action: BattleAction): Promise<ActionResult>;
  
  // é€ƒèµ°è©¦è¡Œ
  attemptEscape(): Promise<EscapeResult>;
  
  // æˆ¦é—˜çµ‚äº†ãƒã‚§ãƒƒã‚¯
  checkBattleEnd(): BattleEndCheck;
  
  // ç¾åœ¨ã®çŠ¶æ…‹å–å¾—
  getState(): BattleState;
  
  // æˆ¦é—˜çµ‚äº†
  endBattle(): BattleRewards;
}
```

### Core Engine å§”è­²

- `combat/turnOrder.calculateTurnOrder()` - è¡Œå‹•é †è¨ˆç®—
- `combat/turnOrder.checkPreemptiveStrike()` - å…ˆåˆ¶æ”»æ’ƒåˆ¤å®š
- `combat/damage.calculatePhysicalDamage()` - ç‰©ç†ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
- `combat/damage.calculateMagicDamage()` - é­”æ³•ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
- `combat/accuracy.checkHit()` - å‘½ä¸­åˆ¤å®š
- `combat/accuracy.checkCritical()` - ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«åˆ¤å®š
- `combat/victory.checkVictoryCondition()` - å‹åˆ©æ¡ä»¶åˆ¤å®š
- `combat/victory.checkDefeatCondition()` - æ•—åŒ—æ¡ä»¶åˆ¤å®š
- `combat/victory.calculateEscapeRate()` - é€ƒèµ°æˆåŠŸç‡è¨ˆç®—
- `status/duration.updateEffectDuration()` - çŠ¶æ…‹ç•°å¸¸ã®æŒç¶šæ™‚é–“æ›´æ–°

### ãƒ•ãƒ­ãƒ¼

```
1. startBattle() â†’ åˆæœŸåŒ–
   â†“
2. calculateTurnOrder() â†’ è¡Œå‹•é †æ±ºå®š
   â†“
3. [ãƒ«ãƒ¼ãƒ—é–‹å§‹]
   â†“
4. advanceTurn() â†’ æ¬¡ã®è¡Œå‹•è€…ã‚’å–å¾—
   â†“
5. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³ï¼Ÿ
   â”œâ”€Yesâ†’ CommandServiceã§å…¥åŠ›å¾…ã¡
   â””â”€No â†’ EnemyAIServiceã§è¡Œå‹•æ±ºå®š
   â†“
6. executeAction() â†’ è¡Œå‹•å®Ÿè¡Œ
   â†“
7. checkBattleEnd() â†’ å‹æ•—åˆ¤å®š
   â”œâ”€ç¶™ç¶š â†’ 3ã«æˆ»ã‚‹
   â””â”€çµ‚äº† â†’ 8ã¸
   â†“
8. endBattle() â†’ å ±é…¬è¨ˆç®—ãƒ»æˆ¦é—˜çµ‚äº†
```

### å®Ÿè£…ä¾‹

```typescript
class BattleService {
  constructor(
    private coreEngine: CoreEngine,
    private commandService: CommandService,
    private enemyAIService: EnemyAIService
  ) {}
  
  async startBattle(party: Character[], enemies: Enemy[]): Promise<void> {
    // æˆ¦é—˜åˆæœŸåŒ–
    this.state = {
      phase: 'initializing',
      turnNumber: 0,
      playerParty: [...party],
      enemyGroup: [...enemies],
      turnOrder: [],
      currentActorIndex: 0,
      actionHistory: []
    };
    
    // å…ˆåˆ¶æ”»æ’ƒãƒã‚§ãƒƒã‚¯
    const preemptive = this.coreEngine.checkPreemptiveStrike(party, enemies);
    
    // è¡Œå‹•é †è¨ˆç®—
    const allCombatants = [...party, ...enemies];
    this.state.turnOrder = this.coreEngine.calculateTurnOrder(allCombatants);
    
    this.state.phase = 'player-turn';
  }
  
  async advanceTurn(): Promise<void> {
    // æ¬¡ã®è¡Œå‹•è€…ã‚’å–å¾—
    const actor = this.state.turnOrder[this.state.currentActorIndex];
    
    if (!actor || actor.currentHp <= 0) {
      // ã‚¹ã‚­ãƒƒãƒ—
      this.currentActorIndex++;
      return this.advanceTurn();
    }
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹æ•µã‹ã§åˆ†å²
    if (this.isPlayerCharacter(actor)) {
      this.state.phase = 'player-turn';
      // UIã§å…¥åŠ›ã‚’å¾…ã¤
    } else {
      this.state.phase = 'enemy-turn';
      // AIã§è¡Œå‹•æ±ºå®š
      const action = await this.enemyAIService.decideAction(actor as Enemy, this.state);
      await this.executeAction(actor, action);
    }
  }
  
  checkBattleEnd(): BattleEndCheck {
    // å‹åˆ©æ¡ä»¶ãƒã‚§ãƒƒã‚¯
    if (this.coreEngine.checkVictoryCondition(this.state.enemyGroup)) {
      return { isEnded: true, result: 'victory' };
    }
    
    // æ•—åŒ—æ¡ä»¶ãƒã‚§ãƒƒã‚¯
    if (this.coreEngine.checkDefeatCondition(this.state.playerParty)) {
      return { isEnded: true, result: 'defeat' };
    }
    
    return { isEnded: false };
  }
}
```

---

## 2. CommandService - æˆ¦é—˜ä¸­ã®ã‚³ãƒãƒ³ãƒ‰é¸æŠ

### æ¦‚è¦
æˆ¦é—˜ä¸­ã®ã‚³ãƒãƒ³ãƒ‰ï¼ˆæ”»æ’ƒãƒ»ã‚¹ã‚­ãƒ«ãƒ»ã‚¢ã‚¤ãƒ†ãƒ ãƒ»é˜²å¾¡ãƒ»é€ƒèµ°ï¼‰ã®é¸æŠè‚¢æç¤ºã¨æ±ºå®šå‡¦ç†ã‚’ç®¡ç†ã€‚

### çŠ¶æ…‹ç®¡ç†

```typescript
interface CommandState {
  // ç¾åœ¨ã®ã‚³ãƒãƒ³ãƒ‰é¸æŠæ®µéš
  stage: 'selecting-action' | 'selecting-skill' | 'selecting-item' | 'selecting-target';
  
  // è¡Œå‹•ä¸­ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
  actor: Character;
  
  // é¸æŠä¸­ã®ã‚³ãƒãƒ³ãƒ‰
  selectedCommand?: 'attack' | 'skill' | 'item' | 'defend' | 'escape';
  selectedSkill?: Skill;
  selectedItem?: Item;
  selectedTargets?: Combatant[];
  
  // åˆ©ç”¨å¯èƒ½ãªé¸æŠè‚¢
  availableCommands: CommandOption[];
  availableSkills: Skill[];
  availableItems: Item[];
  availableTargets: Combatant[];
}
```

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class CommandService {
  // ã‚³ãƒãƒ³ãƒ‰é¸æŠé–‹å§‹
  startCommandSelection(actor: Character, battleState: BattleState): CommandState;
  
  // åˆ©ç”¨å¯èƒ½ãªã‚³ãƒãƒ³ãƒ‰ã‚’å–å¾—
  getAvailableCommands(actor: Character): CommandOption[];
  
  // ã‚³ãƒãƒ³ãƒ‰é¸æŠ
  selectCommand(command: string): void;
  
  // ã‚¹ã‚­ãƒ«/ã‚¢ã‚¤ãƒ†ãƒ é¸æŠ
  selectSkill(skill: Skill): void;
  selectItem(item: Item): void;
  
  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
  selectTarget(target: Combatant): void;
  selectTargets(targets: Combatant[]): void;
  
  // æ±ºå®š
  confirm(): BattleAction;
  
  // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  cancel(): void;
}
```

### Core Engine å§”è­²

- `character/skill.checkSkillUsable()` - ã‚¹ã‚­ãƒ«ä½¿ç”¨å¯å¦åˆ¤å®š
- `character/skill.calculateSkillCost()` - ã‚¹ã‚­ãƒ«ã‚³ã‚¹ãƒˆè¨ˆç®—
- `item/effects.checkItemUsable()` - ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨å¯å¦åˆ¤å®š
- `item/effects.getItemTargets()` - ã‚¢ã‚¤ãƒ†ãƒ å¯¾è±¡å–å¾—

### ãƒ•ãƒ­ãƒ¼

```
1. startCommandSelection() â†’ é¸æŠé–‹å§‹
   â†“
2. getAvailableCommands() â†’ ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§è¡¨ç¤º
   â†“
3. selectCommand() â†’ ã‚³ãƒãƒ³ãƒ‰é¸æŠ
   â†“
4. ã‚³ãƒãƒ³ãƒ‰ã«å¿œã˜ã¦åˆ†å²:
   - æ”»æ’ƒ â†’ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠã¸
   - ã‚¹ã‚­ãƒ« â†’ ã‚¹ã‚­ãƒ«ä¸€è¦§è¡¨ç¤º
   - ã‚¢ã‚¤ãƒ†ãƒ  â†’ ã‚¢ã‚¤ãƒ†ãƒ ä¸€è¦§è¡¨ç¤º
   - é˜²å¾¡ â†’ å³ç¢ºå®š
   - é€ƒèµ° â†’ å³å®Ÿè¡Œ
   â†“
5. selectSkill/selectItem() â†’ è©³ç´°é¸æŠ
   â†“
6. selectTarget() â†’ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
   â†“
7. confirm() â†’ è¡Œå‹•ç¢ºå®šã€BattleActionã‚’è¿”ã™
```

### å®Ÿè£…ä¾‹

```typescript
class CommandService {
  constructor(private coreEngine: CoreEngine) {}
  
  getAvailableCommands(actor: Character): CommandOption[] {
    const commands: CommandOption[] = [];
    
    // æ”»æ’ƒã¯å¸¸ã«å¯èƒ½
    commands.push({ type: 'attack', label: 'æ”»æ’ƒ', enabled: true });
    
    // ã‚¹ã‚­ãƒ«ãƒã‚§ãƒƒã‚¯
    const usableSkills = actor.skills.filter(skill => 
      this.coreEngine.checkSkillUsable(actor, skill)
    );
    if (usableSkills.length > 0) {
      commands.push({ type: 'skill', label: 'ã‚¹ã‚­ãƒ«', enabled: true });
    }
    
    // ã‚¢ã‚¤ãƒ†ãƒ ãƒã‚§ãƒƒã‚¯
    const usableItems = this.getUsableItemsInBattle(actor);
    if (usableItems.length > 0) {
      commands.push({ type: 'item', label: 'ã‚¢ã‚¤ãƒ†ãƒ ', enabled: true });
    }
    
    // é˜²å¾¡ã¯å¸¸ã«å¯èƒ½
    commands.push({ type: 'defend', label: 'é˜²å¾¡', enabled: true });
    
    // é€ƒèµ°ã¯å¸¸ã«è©¦è¡Œå¯èƒ½
    commands.push({ type: 'escape', label: 'é€ƒã’ã‚‹', enabled: true });
    
    return commands;
  }
  
  selectCommand(command: string): void {
    this.state.selectedCommand = command as any;
    
    switch (command) {
      case 'attack':
        this.state.stage = 'selecting-target';
        this.state.availableTargets = this.getAttackTargets();
        break;
        
      case 'skill':
        this.state.stage = 'selecting-skill';
        this.state.availableSkills = this.getUsableSkills(this.state.actor);
        break;
        
      case 'item':
        this.state.stage = 'selecting-item';
        this.state.availableItems = this.getUsableItemsInBattle(this.state.actor);
        break;
        
      case 'defend':
      case 'escape':
        // ã™ãã«ç¢ºå®š
        break;
    }
  }
  
  confirm(): BattleAction {
    return {
      actor: this.state.actor,
      type: this.state.selectedCommand!,
      skill: this.state.selectedSkill,
      item: this.state.selectedItem,
      targets: this.state.selectedTargets || []
    };
  }
}
```

---

## 3. ItemService - ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨ã®æµã‚Œ

### æ¦‚è¦
æˆ¦é—˜ä¸­ãƒ»ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ã®ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨ã®æµã‚Œã‚’ç®¡ç†ã€‚ä½¿ç”¨å¯å¦åˆ¤å®šã€å¯¾è±¡é¸æŠã€åŠ¹æœé©ç”¨ã‚’è¡Œã†ã€‚

### çŠ¶æ…‹ç®¡ç†

```typescript
interface ItemUseState {
  // ä½¿ç”¨æ®µéš
  stage: 'selecting-item' | 'selecting-target' | 'confirming' | 'applying';
  
  // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
  context: 'battle' | 'field';
  
  // é¸æŠ
  selectedItem?: Item;
  selectedTargets?: Character[];
  
  // çµæœ
  result?: ItemUseResult;
}
```

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class ItemService {
  // ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨é–‹å§‹
  startItemUse(context: 'battle' | 'field'): ItemUseState;
  
  // ä½¿ç”¨å¯èƒ½ãªã‚¢ã‚¤ãƒ†ãƒ å–å¾—
  getUsableItems(context: 'battle' | 'field'): Item[];
  
  // ã‚¢ã‚¤ãƒ†ãƒ é¸æŠ
  selectItem(item: Item): void;
  
  // å¯¾è±¡é¸æŠ
  selectTargets(targets: Character[]): void;
  
  // ä½¿ç”¨å®Ÿè¡Œ
  useItem(): Promise<ItemUseResult>;
  
  // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  cancel(): void;
}
```

### Core Engine å§”è­²

- `item/effects.checkItemUsable()` - ä½¿ç”¨å¯å¦åˆ¤å®š
- `item/effects.calculateItemEffect()` - ã‚¢ã‚¤ãƒ†ãƒ åŠ¹æœè¨ˆç®—
- `item/effects.getItemTargets()` - å¯¾è±¡å–å¾—
- `item/inventory.removeItemFromInventory()` - ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å‰Šé™¤

### å®Ÿè£…ä¾‹

```typescript
class ItemService {
  constructor(private coreEngine: CoreEngine) {}
  
  getUsableItems(context: 'battle' | 'field'): Item[] {
    return this.inventory.items.filter(item => 
      this.coreEngine.checkItemUsable(item, context)
    );
  }
  
  async useItem(): Promise<ItemUseResult> {
    const item = this.state.selectedItem!;
    const targets = this.state.selectedTargets!;
    
    const results: ItemEffectResult[] = [];
    
    // å„ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«åŠ¹æœé©ç”¨
    for (const target of targets) {
      const effect = this.coreEngine.calculateItemEffect(
        item,
        target,
        this.state.context
      );
      
      // åŠ¹æœé©ç”¨
      this.applyItemEffect(target, effect);
      results.push(effect);
    }
    
    // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å‰Šé™¤
    this.coreEngine.removeItemFromInventory(this.inventory, item, 1);
    
    return {
      success: true,
      item,
      targets,
      effects: results
    };
  }
}
```

---

## 4. EnemyAIService - æ•µã®è¡Œå‹•è‡ªå‹•æ±ºå®š

### æ¦‚è¦
æ•µã®è¡Œå‹•ã‚’è‡ªå‹•æ±ºå®šã™ã‚‹ã€‚AIæˆ¦ç•¥ã«åŸºã¥ã„ã¦ã‚¹ã‚­ãƒ«ã¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’é¸æŠã€‚

### çŠ¶æ…‹ç®¡ç†

```typescript
interface AIDecisionState {
  // åˆ¤æ–­ä¸­ã®æ•µ
  enemy: Enemy;
  
  // æˆ¦é—˜çŠ¶æ³
  situation: BattleSituation;
  
  // è©•ä¾¡çµæœ
  skillEvaluations: SkillEvaluation[];
  targetEvaluations: TargetEvaluation[];
  
  // æ±ºå®šçµæœ
  decision?: AIDecision;
}
```

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class EnemyAIService {
  // è¡Œå‹•æ±ºå®š
  decideAction(enemy: Enemy, battleState: BattleState): Promise<BattleAction>;
  
  // ã‚¹ã‚­ãƒ«è©•ä¾¡
  evaluateSkills(enemy: Enemy, situation: BattleSituation): SkillEvaluation[];
  
  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè©•ä¾¡
  evaluateTargets(enemy: Enemy, skill: Skill, targets: Character[]): TargetEvaluation[];
  
  // æœ€é©ãªã‚¹ã‚­ãƒ«é¸æŠ
  selectBestSkill(evaluations: SkillEvaluation[]): Skill;
  
  // æœ€é©ãªã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
  selectBestTarget(evaluations: TargetEvaluation[]): Character;
}
```

### Core Engine å§”è­²

- `enemy/ai.evaluateSkill()` - ã‚¹ã‚­ãƒ«è©•ä¾¡
- `enemy/ai.selectBestSkill()` - æœ€é©ã‚¹ã‚­ãƒ«é¸æŠ
- `enemy/ai.evaluateTarget()` - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè©•ä¾¡
- `enemy/ai.selectBestTarget()` - æœ€é©ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
- `character/skill.checkSkillUsable()` - ã‚¹ã‚­ãƒ«ä½¿ç”¨å¯å¦

### å®Ÿè£…ä¾‹

```typescript
class EnemyAIService {
  constructor(private coreEngine: CoreEngine) {}
  
  async decideAction(enemy: Enemy, battleState: BattleState): Promise<BattleAction> {
    // æˆ¦é—˜çŠ¶æ³ã‚’æ§‹ç¯‰
    const situation: BattleSituation = {
      turn: battleState.turnNumber,
      allyParty: battleState.enemyGroup,
      enemyParty: battleState.playerParty,
      averageAllyHpRate: this.calculateAverageHpRate(battleState.enemyGroup),
      averageEnemyHpRate: this.calculateAverageHpRate(battleState.playerParty),
      defeatedAllies: battleState.enemyGroup.filter(e => e.currentHp <= 0).length,
      defeatedEnemies: battleState.playerParty.filter(c => c.currentHp <= 0).length
    };
    
    // ä½¿ç”¨å¯èƒ½ãªã‚¹ã‚­ãƒ«ã‚’å–å¾—
    const availableSkills = enemy.skills.filter(skill =>
      this.coreEngine.checkSkillUsable(enemy, skill)
    );
    
    // ã‚¹ã‚­ãƒ«è©•ä¾¡
    const skillEvaluations = availableSkills.map(skill =>
      this.coreEngine.evaluateSkill(enemy, skill, situation)
    );
    
    // æœ€é©ã‚¹ã‚­ãƒ«é¸æŠ
    const bestSkill = this.coreEngine.selectBestSkill(
      enemy,
      availableSkills,
      situation,
      enemy.aiStrategy
    );
    
    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå€™è£œ
    const possibleTargets = battleState.playerParty.filter(c => c.currentHp > 0);
    
    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè©•ä¾¡
    const targetEvaluations = possibleTargets.map(target =>
      this.coreEngine.evaluateTarget(enemy, target, bestSkill)
    );
    
    // æœ€é©ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
    const bestTarget = this.coreEngine.selectBestTarget(
      enemy,
      possibleTargets,
      bestSkill,
      enemy.aiStrategy
    );
    
    return {
      actor: enemy,
      type: 'skill',
      skill: bestSkill,
      targets: [bestTarget]
    };
  }
}
```

---

## 5. EnemyGroupService - æ•µã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç†

### æ¦‚è¦
æˆ¦é—˜ã«ç™»å ´ã™ã‚‹æ•µã‚°ãƒ«ãƒ¼ãƒ—ã®ç”Ÿæˆã€ç®¡ç†ã€ãƒ‰ãƒ­ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã®æ±ºå®šã‚’è¡Œã†ã€‚

### çŠ¶æ…‹ç®¡ç†

```typescript
interface EnemyGroupState {
  // æ•µã‚°ãƒ«ãƒ¼ãƒ—
  enemies: Enemy[];
  
  // ã‚°ãƒ«ãƒ¼ãƒ—æƒ…å ±
  groupType: string;
  difficulty: number;
  
  // ãƒ‰ãƒ­ãƒƒãƒ—
  potentialDrops: DropItem[];
}
```

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class EnemyGroupService {
  // æ•µã‚°ãƒ«ãƒ¼ãƒ—ç”Ÿæˆ
  generateEnemyGroup(groupType: string, level: number): Enemy[];
  
  // æ•µã®åˆæœŸåŒ–
  initializeEnemy(enemyType: EnemyType, level: number): Enemy;
  
  // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ æ±ºå®š
  rollDrops(defeatedEnemies: Enemy[]): Item[];
  
  // çµŒé¨“å€¤ãƒ»ãŠé‡‘è¨ˆç®—
  calculateRewards(defeatedEnemies: Enemy[]): { exp: number; money: number };
}
```

### Core Engine å§”è­²

- `enemy/stats.generateEnemyStats()` - æ•µã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”Ÿæˆ
- `enemy/stats.getEnemySkills()` - æ•µã‚¹ã‚­ãƒ«å–å¾—
- `enemy/drops.rollDrops()` - ãƒ‰ãƒ­ãƒƒãƒ—åˆ¤å®š
- `enemy/drops.calculateExpReward()` - çµŒé¨“å€¤è¨ˆç®—
- `enemy/drops.calculateMoneyReward()` - ãŠé‡‘è¨ˆç®—

### å®Ÿè£…ä¾‹

```typescript
class EnemyGroupService {
  constructor(private coreEngine: CoreEngine) {}
  
  initializeEnemy(enemyType: EnemyType, level: number): Enemy {
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”Ÿæˆ
    const stats = this.coreEngine.generateEnemyStats(enemyType, level);
    
    // ã‚¹ã‚­ãƒ«å–å¾—
    const skills = this.coreEngine.getEnemySkills(enemyType);
    
    return {
      id: generateId(),
      enemyType,
      level,
      stats,
      currentHp: stats.maxHp,
      currentMp: stats.maxMp,
      skills,
      statusEffects: [],
      aiStrategy: enemyType.aiStrategy,
      position: 0,
      name: enemyType.name
    };
  }
  
  rollDrops(defeatedEnemies: Enemy[]): Item[] {
    const allDrops: Item[] = [];
    
    for (const enemy of defeatedEnemies) {
      const drops = this.coreEngine.rollDrops(enemy);
      allDrops.push(...drops);
    }
    
    return allDrops;
  }
  
  calculateRewards(defeatedEnemies: Enemy[]): { exp: number; money: number } {
    let totalExp = 0;
    let totalMoney = 0;
    
    for (const enemy of defeatedEnemies) {
      totalExp += this.coreEngine.calculateExpReward(enemy);
      totalMoney += this.coreEngine.calculateMoneyReward(enemy);
    }
    
    return { exp: totalExp, money: totalMoney };
  }
}
```

---

## 6. SkillLearnService - ã‚¹ã‚­ãƒ«ç¿’å¾—ç®¡ç†

### æ¦‚è¦
ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ã‚¹ã‚­ãƒ«ç¿’å¾—ã®æµã‚Œã‚’ç®¡ç†ã€‚ç¿’å¾—æ¡ä»¶ãƒã‚§ãƒƒã‚¯ã€ç¿’å¾—å‡¦ç†ã‚’è¡Œã†ã€‚

### çŠ¶æ…‹ç®¡ç†

```typescript
interface SkillLearnState {
  // å¯¾è±¡ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
  character: Character;
  
  // ç¿’å¾—å¯èƒ½ã‚¹ã‚­ãƒ«
  learnableSkills: Skill[];
  
  // é¸æŠä¸­ã®ã‚¹ã‚­ãƒ«
  selectedSkill?: Skill;
  
  // ã‚³ã‚¹ãƒˆ
  cost?: number;
}
```

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class SkillLearnService {
  // ç¿’å¾—å¯èƒ½ã‚¹ã‚­ãƒ«å–å¾—
  getLearnableSkills(character: Character): Skill[];
  
  // ç¿’å¾—æ¡ä»¶ãƒã‚§ãƒƒã‚¯
  checkLearnCondition(character: Character, skill: Skill): LearnConditionCheck;
  
  // ã‚¹ã‚­ãƒ«ç¿’å¾—
  learnSkill(character: Character, skill: Skill): LearnResult;
}
```

### Core Engine å§”è­²

- `character/skill.checkSkillLearnCondition()` - ç¿’å¾—æ¡ä»¶åˆ¤å®š
- `character/skill.getLearnableSkills()` - ç¿’å¾—å¯èƒ½ã‚¹ã‚­ãƒ«å–å¾—

### å®Ÿè£…ä¾‹

```typescript
class SkillLearnService {
  constructor(private coreEngine: CoreEngine) {}
  
  getLearnableSkills(character: Character): Skill[] {
    // Core Engineã‹ã‚‰ç¿’å¾—å¯èƒ½ãªã‚¹ã‚­ãƒ«ã‚’å–å¾—
    return this.coreEngine.getLearnableSkills(character);
  }
  
  checkLearnCondition(character: Character, skill: Skill): LearnConditionCheck {
    // Core Engineã§æ¡ä»¶ãƒã‚§ãƒƒã‚¯
    const conditionCheck = this.coreEngine.checkSkillLearnCondition(character, skill);
    
    return {
      canLearn: conditionCheck.canLearn,
      missingConditions: conditionCheck.missingConditions,
      cost: conditionCheck.cost
    };
  }
  
  learnSkill(character: Character, skill: Skill): LearnResult {
    // æ¡ä»¶ãƒã‚§ãƒƒã‚¯
    const check = this.checkLearnCondition(character, skill);
    if (!check.canLearn) {
      return {
        success: false,
        message: 'ç¿’å¾—æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“',
        missingConditions: check.missingConditions
      };
    }
    
    // ã‚¹ã‚­ãƒ«ãƒã‚¤ãƒ³ãƒˆãƒ»ã‚³ã‚¹ãƒˆæ¶ˆè²»
    if (check.cost > 0) {
      if (character.skillPoints < check.cost) {
        return {
          success: false,
          message: 'ã‚¹ã‚­ãƒ«ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™'
        };
      }
      character.skillPoints -= check.cost;
    }
    
    // ã‚¹ã‚­ãƒ«ã‚’ç¿’å¾—
    character.skills.push(skill);
    
    return {
      success: true,
      message: `${skill.name}ã‚’ç¿’å¾—ã—ã¾ã—ãŸï¼`,
      learnedSkill: skill
    };
  }
}
```

---

## 7. JobChangeService - è·æ¥­ãƒ»ã‚¯ãƒ©ã‚¹å¤‰æ›´

### æ¦‚è¦
ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ã‚¸ãƒ§ãƒ–å¤‰æ›´ã®æµã‚Œã‚’ç®¡ç†ã€‚å¤‰æ›´æ¡ä»¶ãƒã‚§ãƒƒã‚¯ã€ã‚¸ãƒ§ãƒ–å¤‰æ›´å‡¦ç†ã‚’è¡Œã†ã€‚

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class JobChangeService {
  // è»¢è·å¯èƒ½ã‚¸ãƒ§ãƒ–å–å¾—
  getAvailableJobs(character: Character): Job[];
  
  // è»¢è·æ¡ä»¶ãƒã‚§ãƒƒã‚¯
  checkJobChangeCondition(character: Character, targetJob: Job): JobChangeConditionCheck;
  
  // ã‚¸ãƒ§ãƒ–å¤‰æ›´å®Ÿè¡Œ
  changeJob(character: Character, targetJob: Job): JobChangeResult;
}
```

### Core Engine å§”è­²

- `character/job.getAvailableJobs()` - è»¢è·å¯èƒ½ã‚¸ãƒ§ãƒ–
- `character/job.checkJobChangeCondition()` - è»¢è·æ¡ä»¶åˆ¤å®š
- `character/job.calculateJobStatModifier()` - ã‚¸ãƒ§ãƒ–ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è£œæ­£
- `character/stats.calculateFinalStats()` - æœ€çµ‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å†è¨ˆç®—

### å®Ÿè£…ä¾‹

```typescript
class JobChangeService {
  constructor(private coreEngine: CoreEngine) {}
  
  getAvailableJobs(character: Character): Job[] {
    // Core Engineã‹ã‚‰è»¢è·å¯èƒ½ãªã‚¸ãƒ§ãƒ–ã‚’å–å¾—
    return this.coreEngine.getAvailableJobs(character);
  }
  
  checkJobChangeCondition(character: Character, targetJob: Job): JobChangeConditionCheck {
    // Core Engineã§æ¡ä»¶ãƒã‚§ãƒƒã‚¯
    return this.coreEngine.checkJobChangeCondition(character, targetJob);
  }
  
  changeJob(character: Character, targetJob: Job): JobChangeResult {
    // æ¡ä»¶ãƒã‚§ãƒƒã‚¯
    const check = this.checkJobChangeCondition(character, targetJob);
    if (!check.canChange) {
      return {
        success: false,
        message: 'è»¢è·æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“',
        missingConditions: check.missingConditions
      };
    }
    
    const previousJob = character.job;
    
    // ã‚¸ãƒ§ãƒ–å¤‰æ›´å‰ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ä¿å­˜
    const previousStats = { ...character.stats };
    
    // ã‚¸ãƒ§ãƒ–å¤‰æ›´
    character.job = targetJob;
    
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å†è¨ˆç®—
    character.stats = this.coreEngine.calculateFinalStats(character);
    
    // ã‚¹ã‚­ãƒ«ã®ç²å¾—ãƒ»å–ªå¤±
    const gainedSkills = targetJob.defaultSkills.filter(
      skill => !character.skills.find(s => s.id === skill.id)
    );
    const lostSkills = previousJob.defaultSkills.filter(
      skill => !targetJob.defaultSkills.find(s => s.id === skill.id)
    );
    
    // ã‚¸ãƒ§ãƒ–å›ºæœ‰ã‚¹ã‚­ãƒ«ã®æ›´æ–°
    character.skills = character.skills.filter(
      skill => !lostSkills.find(s => s.id === skill.id)
    );
    character.skills.push(...gainedSkills);
    
    return {
      success: true,
      message: `${targetJob.name}ã«è»¢è·ã—ã¾ã—ãŸï¼`,
      previousJob,
      newJob: targetJob,
      statChanges: {
        attack: character.stats.attack - previousStats.attack,
        defense: character.stats.defense - previousStats.defense,
        magicAttack: character.stats.magicAttack - previousStats.magicAttack,
        magicDefense: character.stats.magicDefense - previousStats.magicDefense,
        speed: character.stats.speed - previousStats.speed
      },
      gainedSkills,
      lostSkills
    };
  }
}
```

---

## 8. RewardService - æˆ¦é—˜å ±é…¬å‡¦ç†

### æ¦‚è¦
æˆ¦é—˜çµ‚äº†å¾Œã®å ±é…¬ï¼ˆçµŒé¨“å€¤ã€ãŠé‡‘ã€ã‚¢ã‚¤ãƒ†ãƒ ï¼‰ã®é…åˆ†ã¨ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—å‡¦ç†ã‚’ç®¡ç†ã€‚

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class RewardService {
  // å ±é…¬é…åˆ†
  distributeRewards(party: Character[], rewards: BattleRewards): RewardDistributionResult;
  
  // çµŒé¨“å€¤é…åˆ†
  distributeExp(party: Character[], totalExp: number): Map<Character, number>;
  
  // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—å‡¦ç†
  processLevelUps(character: Character, gainedExp: number): LevelUpResult[];
  
  // ã‚¢ã‚¤ãƒ†ãƒ è¿½åŠ 
  addItems(inventory: Inventory, items: Item[]): InventoryResult;
}
```

### Core Engine å§”è­²

- `character/growth.distributeExpToParty()` - çµŒé¨“å€¤é…åˆ†
- `character/growth.checkLevelUp()` - ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—åˆ¤å®š
- `character/growth.calculateStatGrowth()` - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æˆé•·è¨ˆç®—
- `item/inventory.addItemToInventory()` - ã‚¢ã‚¤ãƒ†ãƒ è¿½åŠ 

### å®Ÿè£…ä¾‹

```typescript
class RewardService {
  constructor(
    private coreEngine: CoreEngine,
    private inventoryService: InventoryService
  ) {}
  
  distributeRewards(party: Character[], rewards: BattleRewards): RewardDistributionResult {
    // çµŒé¨“å€¤é…åˆ†
    const expDistribution = this.distributeExp(party, rewards.exp);
    
    // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—å‡¦ç†
    const levelUpResults: Map<Character, LevelUpResult[]> = new Map();
    for (const [character, gainedExp] of expDistribution.entries()) {
      const levelUps = this.processLevelUps(character, gainedExp);
      if (levelUps.length > 0) {
        levelUpResults.set(character, levelUps);
      }
    }
    
    // ã‚¢ã‚¤ãƒ†ãƒ è¿½åŠ 
    const itemResults = this.addItems(rewards.items);
    
    // ãŠé‡‘è¿½åŠ 
    // gameState.money += rewards.money; // GameStateçµŒç”±ã§è¿½åŠ 
    
    return {
      expDistribution,
      levelUpResults,
      itemResults,
      totalMoney: rewards.money
    };
  }
  
  distributeExp(party: Character[], totalExp: number): Map<Character, number> {
    // Core Engineã§çµŒé¨“å€¤é…åˆ†ã‚’è¨ˆç®—
    const distribution = this.coreEngine.distributeExpToParty(party, totalExp);
    
    // å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã«çµŒé¨“å€¤ã‚’åŠ ç®—
    for (const [character, exp] of distribution.entries()) {
      character.currentExp += exp;
    }
    
    return distribution;
  }
  
  processLevelUps(character: Character, gainedExp: number): LevelUpResult[] {
    const results: LevelUpResult[] = [];
    
    // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—åˆ¤å®šã‚’ç¹°ã‚Šè¿”ã™
    while (this.coreEngine.checkLevelUp(character)) {
      const previousLevel = character.level;
      const previousStats = { ...character.stats };
      
      // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
      character.level++;
      
      // æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã¾ã§ã®å¿…è¦çµŒé¨“å€¤ã‚’å–å¾—
      const expToNext = this.coreEngine.getExpForNextLevel(character.level);
      character.currentExp -= expToNext;
      
      // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æˆé•·
      const statGrowth = this.coreEngine.calculateStatGrowth(character, previousLevel);
      character.stats.maxHp += statGrowth.hp;
      character.stats.maxMp += statGrowth.mp;
      character.stats.attack += statGrowth.attack;
      character.stats.defense += statGrowth.defense;
      character.stats.magicAttack += statGrowth.magicAttack;
      character.stats.magicDefense += statGrowth.magicDefense;
      character.stats.speed += statGrowth.speed;
      
      // HP/MPå…¨å›å¾©
      character.currentHp = character.stats.maxHp;
      character.currentMp = character.stats.maxMp;
      
      // ç¿’å¾—ã‚¹ã‚­ãƒ«
      const newSkills = this.coreEngine.getSkillsLearnedAtLevel(character, character.level);
      character.skills.push(...newSkills);
      
      results.push({
        newLevel: character.level,
        statGrowth,
        newSkills
      });
    }
    
    return results;
  }
  
  addItems(items: Item[]): InventoryResult {
    // InventoryServiceã«å§”è­²
    const results: InventoryResult[] = [];
    for (const item of items) {
      results.push(this.inventoryService.addItem(item, 1));
    }
    
    return {
      success: results.every(r => r.success),
      addedItems: items
    };
  }
}
```

---

## 9. InventoryService - ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒª/ãƒãƒƒã‚°ç®¡ç†

### æ¦‚è¦
ã‚¢ã‚¤ãƒ†ãƒ ã¨è£…å‚™ã®ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªï¼ˆãƒãƒƒã‚°ï¼‰ã‚’ç®¡ç†ã€‚ã‚¢ã‚¤ãƒ†ãƒ ã®è¿½åŠ ãƒ»å‰Šé™¤ã€æ¤œç´¢ã€ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã€ã‚½ãƒ¼ãƒˆãªã©ã®æ©Ÿèƒ½ã‚’æä¾›ã€‚è©³ç´°ãªè¨­è¨ˆã¯ `INVENTORY_SYSTEM_DESIGN.md` ã‚’å‚ç…§ã€‚

### çŠ¶æ…‹ç®¡ç†

```typescript
interface InventoryServiceState {
  // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãƒ‡ãƒ¼ã‚¿
  inventory: Inventory;
  
  // æœ€å¾Œã®æ“ä½œçµæœ
  lastOperation?: {
    type: 'add' | 'remove' | 'use' | 'stack';
    success: boolean;
    message?: string;
  };
}
```

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class InventoryService {
  constructor(
    private coreEngine: CoreEngine,
    private inventory: Inventory
  ) {}
  
  // === ã‚¢ã‚¤ãƒ†ãƒ æ“ä½œ ===
  
  // ã‚¢ã‚¤ãƒ†ãƒ è¿½åŠ 
  addItem(item: Item, quantity: number): InventoryResult;
  
  // ã‚¢ã‚¤ãƒ†ãƒ å‰Šé™¤
  removeItem(item: Item, quantity: number): InventoryResult;
  
  // ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨ï¼ˆItemServiceã«å§”è­²ï¼‰
  useItem(item: Item, context: 'battle' | 'field', targets: Combatant[]): Promise<ItemUseResult>;
  
  // === ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚° ===
  
  // ã‚«ãƒ†ã‚´ãƒªåˆ¥å–å¾—
  getItemsByCategory(category: ItemCategory): InventorySlot[];
  
  // ä½¿ç”¨å¯èƒ½ã‚¢ã‚¤ãƒ†ãƒ å–å¾—
  getUsableItems(context: 'battle' | 'field'): InventorySlot[];
  
  // è£…å‚™å¯èƒ½ã‚¢ã‚¤ãƒ†ãƒ å–å¾—
  getEquippableItems(character: Character): InventorySlot[];
  
  // è£…å‚™ä¸­ã‚¢ã‚¤ãƒ†ãƒ å–å¾—
  getEquippedItems(): InventorySlot[];
  
  // ã‚«ã‚¹ã‚¿ãƒ æ¤œç´¢
  searchItems(criteria: InventorySearchCriteria): InventorySlot[];
  
  // === ã‚½ãƒ¼ãƒˆãƒ»æ•´ç† ===
  
  // ã‚½ãƒ¼ãƒˆ
  sortInventory(sortBy: InventorySortBy, order: SortOrder): void;
  
  // ã‚¹ã‚¿ãƒƒã‚¯æ•´ç†
  stackItems(): StackResult;
  
  // === çµ±è¨ˆãƒ»æƒ…å ± ===
  
  // çµ±è¨ˆæƒ…å ±å–å¾—
  getStats(): InventoryStats;
  
  // ç©ºãã‚¹ãƒ­ãƒƒãƒˆå–å¾—
  getAvailableSlots(): number;
  
  // ã‚¢ã‚¤ãƒ†ãƒ æ‰€æŒãƒã‚§ãƒƒã‚¯
  hasItem(itemId: UniqueId, quantity: number): boolean;
}
```

### Core Engine å§”è­²

- `item/inventory.addItemToInventory()` - ã‚¢ã‚¤ãƒ†ãƒ è¿½åŠ 
- `item/inventory.removeItemFromInventory()` - ã‚¢ã‚¤ãƒ†ãƒ å‰Šé™¤
- `item/inventory.searchItems()` - ã‚¢ã‚¤ãƒ†ãƒ æ¤œç´¢
- `item/inventory.sortInventory()` - ã‚¢ã‚¤ãƒ†ãƒ ã‚½ãƒ¼ãƒˆ
- `item/inventory.stackItems()` - ã‚¹ã‚¿ãƒƒã‚¯æ•´ç†
- `item/inventory.getInventoryStats()` - çµ±è¨ˆæƒ…å ±å–å¾—
- `item/effects.checkItemUsable()` - ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨å¯å¦åˆ¤å®šï¼ˆItemServiceã¨é€£æºï¼‰
- `item/equipment.checkEquipmentEligibility()` - è£…å‚™å¯å¦åˆ¤å®šï¼ˆEquipmentServiceã¨é€£æºï¼‰

### ä»–ã®Serviceã¨ã®é€£æº

#### ItemService ã¨ã®é€£æº
```typescript
// ItemServiceå†…ã§InventoryServiceã‚’å‚ç…§
class ItemService {
  constructor(
    private coreEngine: CoreEngine,
    private inventoryService: InventoryService
  ) {}
  
  getUsableItems(context: 'battle' | 'field'): Item[] {
    // InventoryServiceã‹ã‚‰ä½¿ç”¨å¯èƒ½ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
    return this.inventoryService.getUsableItems(context)
      .map(slot => slot.item);
  }
  
  async useItem(item: Item, targets: Combatant[], context: 'battle' | 'field'): Promise<ItemUseResult> {
    // ã‚¢ã‚¤ãƒ†ãƒ åŠ¹æœé©ç”¨
    const result = await this.applyItemEffects(item, targets, context);
    
    // æˆåŠŸã—ãŸã‚‰ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å‰Šé™¤
    if (result.success) {
      this.inventoryService.removeItem(item, 1);
    }
    
    return result;
  }
}
```

#### EquipmentService ã¨ã®é€£æº
```typescript
// EquipmentServiceå†…ã§InventoryServiceã‚’å‚ç…§
class EquipmentService {
  constructor(
    private coreEngine: CoreEngine,
    private inventoryService: InventoryService
  ) {}
  
  getEquippableItems(character: Character): Equipment[] {
    // InventoryServiceã‹ã‚‰è£…å‚™å¯èƒ½ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
    return this.inventoryService.getEquippableItems(character)
      .map(slot => slot.item as Equipment);
  }
  
  equipItem(character: Character, equipment: Equipment, slot: EquipmentType): EquipResult {
    // è£…å‚™å‡¦ç†
    const result = this.performEquip(character, equipment, slot);
    
    // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã®è£…å‚™ãƒ•ãƒ©ã‚°ã‚’æ›´æ–°
    if (result.success) {
      // Core Engineã‚’é€šã˜ã¦ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªå†…ã®è£…å‚™ãƒ•ãƒ©ã‚°ã‚’æ›´æ–°
      this.coreEngine.updateEquippedFlag(this.inventoryService.inventory, equipment.id, true);
    }
    
    return result;
  }
}
```

#### RewardService ã¨ã®é€£æº
```typescript
// RewardServiceå†…ã§InventoryServiceã‚’å‚ç…§
class RewardService {
  constructor(
    private coreEngine: CoreEngine,
    private inventoryService: InventoryService
  ) {}
  
  async distributeRewards(rewards: BattleRewards): Promise<RewardResult> {
    // çµŒé¨“å€¤ãƒ»ãŠé‡‘ã‚’é…åˆ†
    const expResult = this.distributeExp(rewards.exp);
    const moneyResult = this.addMoney(rewards.money);
    
    // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«è¿½åŠ 
    const itemResults: InventoryResult[] = [];
    for (const item of rewards.items) {
      const result = this.inventoryService.addItem(item, 1);
      itemResults.push(result);
    }
    
    return {
      exp: expResult,
      money: moneyResult,
      items: itemResults
    };
  }
}
```

#### CraftService ã¨ã®é€£æº
```typescript
// CraftServiceå†…ã§InventoryServiceã‚’å‚ç…§
class CraftService {
  constructor(
    private coreEngine: CoreEngine,
    private inventoryService: InventoryService
  ) {}
  
  checkMaterials(recipe: Recipe): RecipeCheckResult {
    // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰ææ–™ã®æ‰€æŒæ•°ã‚’ãƒã‚§ãƒƒã‚¯
    const materialsAvailable = recipe.materials.every(material =>
      this.inventoryService.hasItem(material.itemId, material.quantity)
    );
    
    return {
      canCraft: materialsAvailable,
      missingMaterials: this.getMissingMaterials(recipe)
    };
  }
  
  synthesize(recipe: Recipe): SynthesisResult {
    // ææ–™ã‚’ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å‰Šé™¤
    for (const material of recipe.materials) {
      this.inventoryService.removeItem(material.item, material.quantity);
    }
    
    // åˆæˆå‡¦ç†
    const result = this.performSynthesis(recipe);
    
    // æˆåŠŸã—ãŸã‚‰çµæœã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«è¿½åŠ 
    if (result.success) {
      this.inventoryService.addItem(result.resultItem, 1);
    }
    
    return result;
  }
}
```

### å®Ÿè£…ä¾‹

```typescript
class InventoryService {
  constructor(
    private coreEngine: CoreEngine,
    private inventory: Inventory
  ) {}
  
  addItem(item: Item, quantity: number): InventoryResult {
    // Core Engineã«å§”è­²
    return this.coreEngine.addItemToInventory(this.inventory, item, quantity);
  }
  
  getUsableItems(context: 'battle' | 'field'): InventorySlot[] {
    // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å…¨ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
    const allItems = this.inventory.slots;
    
    // ä½¿ç”¨å¯èƒ½ãªã‚¢ã‚¤ãƒ†ãƒ ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿
    return allItems.filter(slot => 
      this.coreEngine.checkItemUsable(slot.item, context)
    );
  }
  
  searchItems(criteria: InventorySearchCriteria): InventorySlot[] {
    // Core Engineã«å§”è­²
    return this.coreEngine.searchItems(this.inventory, criteria);
  }
  
  sortInventory(sortBy: InventorySortBy, order: SortOrder): void {
    // Core Engineã«å§”è­²ã—ã¦ã‚½ãƒ¼ãƒˆå®Ÿè¡Œ
    this.coreEngine.sortInventory(this.inventory, sortBy, order);
  }
  
  getStats(): InventoryStats {
    // Core Engineã«å§”è­²
    return this.coreEngine.getInventoryStats(this.inventory);
  }
}
```

---

## 10. EquipmentService - è£…å‚™å¤‰æ›´ç®¡ç†

### æ¦‚è¦
ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®è£…å‚™å¤‰æ›´ã‚’ç®¡ç†ã€‚è£…å‚™å¯å¦åˆ¤å®šã€è£…å‚™å¤‰æ›´ã€æ¯”è¼ƒæ©Ÿèƒ½ã‚’æä¾›ã€‚

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class EquipmentService {
  // è£…å‚™å¯å¦ãƒã‚§ãƒƒã‚¯
  checkEquipmentEligibility(character: Character, equipment: Equipment): EquipmentEligibilityCheck;
  
  // è£…å‚™å¤‰æ›´
  equipItem(character: Character, equipment: Equipment, slot: EquipmentType): EquipResult;
  
  // è£…å‚™è§£é™¤
  unequipItem(character: Character, slot: EquipmentType): UnequipResult;
  
  // è£…å‚™æ¯”è¼ƒ
  compareEquipment(character: Character, currentEquip: Equipment | null, newEquip: Equipment): EquipmentComparison;
}
```

### Core Engine å§”è­²

- `item/equipment.checkEquipmentEligibility()` - è£…å‚™å¯å¦åˆ¤å®š
- `item/equipment.calculateEquipmentBonus()` - è£…å‚™ãƒœãƒ¼ãƒŠã‚¹è¨ˆç®—
- `item/equipment.compareEquipment()` - è£…å‚™æ¯”è¼ƒ
- `character/stats.calculateFinalStats()` - æœ€çµ‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å†è¨ˆç®—

### å®Ÿè£…ä¾‹

```typescript
class EquipmentService {
  constructor(private coreEngine: CoreEngine) {}
  
  checkEquipmentEligibility(character: Character, equipment: Equipment): EquipmentEligibilityCheck {
    // Core Engineã§è£…å‚™å¯å¦åˆ¤å®š
    return this.coreEngine.checkEquipmentEligibility(character, equipment);
  }
  
  equipItem(character: Character, equipment: Equipment, slot: EquipmentType): EquipResult {
    // è£…å‚™å¯å¦ãƒã‚§ãƒƒã‚¯
    const eligibility = this.checkEquipmentEligibility(character, equipment);
    if (!eligibility.canEquip) {
      return {
        success: false,
        message: `è£…å‚™ã§ãã¾ã›ã‚“: ${eligibility.reason}`,
        reasons: eligibility.reasons
      };
    }
    
    // ç¾åœ¨ã®è£…å‚™ã‚’å–å¾—
    const currentEquipment = character.equipment[slot];
    
    // è£…å‚™å¤‰æ›´
    character.equipment[slot] = equipment;
    
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å†è¨ˆç®—
    const previousStats = { ...character.stats };
    character.stats = this.coreEngine.calculateFinalStats(character);
    
    // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã®ãƒ•ãƒ©ã‚°æ›´æ–°
    if (equipment.inventorySlotIndex !== undefined) {
      // equipment.isEquipped = true;
    }
    if (currentEquipment && currentEquipment.inventorySlotIndex !== undefined) {
      // currentEquipment.isEquipped = false;
    }
    
    return {
      success: true,
      message: `${equipment.name}ã‚’è£…å‚™ã—ã¾ã—ãŸ`,
      equippedItem: equipment,
      unequippedItem: currentEquipment,
      statChanges: {
        attack: character.stats.attack - previousStats.attack,
        defense: character.stats.defense - previousStats.defense,
        magicAttack: character.stats.magicAttack - previousStats.magicAttack,
        magicDefense: character.stats.magicDefense - previousStats.magicDefense,
        speed: character.stats.speed - previousStats.speed
      }
    };
  }
  
  unequipItem(character: Character, slot: EquipmentType): UnequipResult {
    const currentEquipment = character.equipment[slot];
    if (!currentEquipment) {
      return {
        success: false,
        message: 'è£…å‚™ã•ã‚Œã¦ã„ã¾ã›ã‚“'
      };
    }
    
    // è£…å‚™è§£é™¤
    character.equipment[slot] = null;
    
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å†è¨ˆç®—
    const previousStats = { ...character.stats };
    character.stats = this.coreEngine.calculateFinalStats(character);
    
    // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã®ãƒ•ãƒ©ã‚°æ›´æ–°
    if (currentEquipment.inventorySlotIndex !== undefined) {
      // currentEquipment.isEquipped = false;
    }
    
    return {
      success: true,
      message: `${currentEquipment.name}ã‚’å¤–ã—ã¾ã—ãŸ`,
      unequippedItem: currentEquipment,
      statChanges: {
        attack: character.stats.attack - previousStats.attack,
        defense: character.stats.defense - previousStats.defense,
        magicAttack: character.stats.magicAttack - previousStats.magicAttack,
        magicDefense: character.stats.magicDefense - previousStats.magicDefense,
        speed: character.stats.speed - previousStats.speed
      }
    };
  }
  
  compareEquipment(character: Character, currentEquip: Equipment | null, newEquip: Equipment): EquipmentComparison {
    // Core Engineã§è£…å‚™æ¯”è¼ƒ
    return this.coreEngine.compareEquipment(character, currentEquip, newEquip);
  }
}
```

---

## 11. PartyService - ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆç®¡ç†

### æ¦‚è¦
ãƒ‘ãƒ¼ãƒ†ã‚£ã®ç·¨æˆã€ãƒ¡ãƒ³ãƒãƒ¼å…¥ã‚Œæ›¿ãˆã€éšŠåˆ—å¤‰æ›´ã‚’ç®¡ç†ã€‚è¤‡æ•°ã®ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆã‚’ãƒ—ãƒªã‚»ãƒƒãƒˆã¨ã—ã¦ä¿å­˜ãƒ»åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ã€‚

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
interface PartyFormation {
  id: string;
  name: string;
  members: Character[];
  formationPositions: number[];
  createdAt: number;
  updatedAt: number;
}

class PartyService {
  // ãƒ¡ãƒ³ãƒãƒ¼è¿½åŠ 
  addMember(party: Character[], character: Character): PartyResult;
  
  // ãƒ¡ãƒ³ãƒãƒ¼å‰Šé™¤
  removeMember(party: Character[], character: Character): PartyResult;
  
  // ãƒ¡ãƒ³ãƒãƒ¼å…¥ã‚Œæ›¿ãˆ
  swapMembers(party: Character[], index1: number, index2: number): PartyResult;
  
  // éšŠåˆ—å¤‰æ›´
  changeFormation(party: Character[], formation: number[]): PartyResult;
  
  // è¤‡æ•°ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆç®¡ç†
  saveFormation(id: string, name: string, party: Character[], formationPositions: number[]): FormationResult;
  loadFormation(id: string): FormationLoadResult;
  deleteFormation(id: string): FormationResult;
  getAllFormations(): PartyFormation[];
  switchToFormation(id: string): FormationSwitchResult;
}
```

### Core Engine å§”è­²

- `party/formation.validatePartyComposition()` - ãƒ‘ãƒ¼ãƒ†ã‚£æ§‹æˆã®æ¤œè¨¼
- `party/formation.saveFormation()` - ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆã®ä¿å­˜
- `party/formation.loadFormation()` - ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆã®èª­ã¿è¾¼ã¿
- `party/formation.deleteFormation()` - ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆã®å‰Šé™¤
- `party/formation.getAllFormations()` - å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆã®å–å¾—

### å®Ÿè£…ä¾‹

```typescript
class PartyService {
  constructor(private coreEngine: CoreEngine) {}
  
  addMember(party: Character[], character: Character): PartyResult {
    // ãƒ‘ãƒ¼ãƒ†ã‚£äººæ•°åˆ¶é™ãƒã‚§ãƒƒã‚¯
    const maxPartySize = 4; // ã‚²ãƒ¼ãƒ è¨­å®šã‹ã‚‰å–å¾—
    if (party.length >= maxPartySize) {
      return {
        success: false,
        message: `ãƒ‘ãƒ¼ãƒ†ã‚£ã¯æœ€å¤§${maxPartySize}äººã¾ã§ã§ã™`
      };
    }
    
    // é‡è¤‡ãƒã‚§ãƒƒã‚¯
    if (party.find(c => c.id === character.id)) {
      return {
        success: false,
        message: 'ã™ã§ã«ãƒ‘ãƒ¼ãƒ†ã‚£ã«å‚åŠ ã—ã¦ã„ã¾ã™'
      };
    }
    
    // ãƒ¡ãƒ³ãƒãƒ¼è¿½åŠ 
    party.push(character);
    
    return {
      success: true,
      message: `${character.name}ãŒãƒ‘ãƒ¼ãƒ†ã‚£ã«åŠ ã‚ã‚Šã¾ã—ãŸ`,
      party: [...party]
    };
  }
  
  removeMember(party: Character[], character: Character): PartyResult {
    const index = party.findIndex(c => c.id === character.id);
    if (index === -1) {
      return {
        success: false,
        message: 'ãƒ‘ãƒ¼ãƒ†ã‚£ã«ã„ã¾ã›ã‚“'
      };
    }
    
    // æœ€ä½äººæ•°ãƒã‚§ãƒƒã‚¯
    if (party.length <= 1) {
      return {
        success: false,
        message: 'ãƒ‘ãƒ¼ãƒ†ã‚£ã«ã¯æœ€ä½1äººå¿…è¦ã§ã™'
      };
    }
    
    // ãƒ¡ãƒ³ãƒãƒ¼å‰Šé™¤
    party.splice(index, 1);
    
    return {
      success: true,
      message: `${character.name}ãŒãƒ‘ãƒ¼ãƒ†ã‚£ã‹ã‚‰å¤–ã‚Œã¾ã—ãŸ`,
      party: [...party]
    };
  }
  
  swapMembers(party: Character[], index1: number, index2: number): PartyResult {
    if (index1 < 0 || index1 >= party.length || index2 < 0 || index2 >= party.length) {
      return {
        success: false,
        message: 'ç„¡åŠ¹ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™'
      };
    }
    
    // ãƒ¡ãƒ³ãƒãƒ¼å…¥ã‚Œæ›¿ãˆ
    [party[index1], party[index2]] = [party[index2], party[index1]];
    
    return {
      success: true,
      message: 'ãƒ¡ãƒ³ãƒãƒ¼ã‚’å…¥ã‚Œæ›¿ãˆã¾ã—ãŸ',
      party: [...party]
    };
  }
  
  changeFormation(party: Character[], formation: number[]): PartyResult {
    // éšŠåˆ—æ¤œè¨¼
    if (formation.length !== party.length) {
      return {
        success: false,
        message: 'éšŠåˆ—ã®é•·ã•ãŒãƒ‘ãƒ¼ãƒ†ã‚£äººæ•°ã¨ä¸€è‡´ã—ã¾ã›ã‚“'
      };
    }
    
    // é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const uniquePositions = new Set(formation);
    if (uniquePositions.size !== formation.length) {
      return {
        success: false,
        message: 'éšŠåˆ—ã«é‡è¤‡ãŒã‚ã‚Šã¾ã™'
      };
    }
    
    // éšŠåˆ—å¤‰æ›´ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã‚’ä¸¦ã³æ›¿ãˆï¼‰
    const newParty = formation.map(pos => party[pos]);
    party.splice(0, party.length, ...newParty);
    
    return {
      success: true,
      message: 'éšŠåˆ—ã‚’å¤‰æ›´ã—ã¾ã—ãŸ',
      party: [...party],
      formation
    };
  }
  
  // è¤‡æ•°ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆç®¡ç†
  saveFormation(id: string, name: string, party: Character[], formationPositions: number[]): FormationResult {
    // Core Engineã«å§”è­²ã—ã¦ä¿å­˜
    const formation: PartyFormation = {
      id,
      name,
      members: [...party],
      formationPositions: [...formationPositions],
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
    
    this.coreEngine.saveFormation(formation);
    
    return {
      success: true,
      message: `ç·¨æˆã€Œ${name}ã€ã‚’ä¿å­˜ã—ã¾ã—ãŸ`,
      formation
    };
  }
  
  loadFormation(id: string): FormationLoadResult {
    // Core Engineã‹ã‚‰èª­ã¿è¾¼ã¿
    const formation = this.coreEngine.loadFormation(id);
    
    if (!formation) {
      return {
        success: false,
        message: 'ç·¨æˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
      };
    }
    
    return {
      success: true,
      message: `ç·¨æˆã€Œ${formation.name}ã€ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`,
      formation
    };
  }
  
  deleteFormation(id: string): FormationResult {
    // Core Engineã‹ã‚‰å‰Šé™¤
    const deleted = this.coreEngine.deleteFormation(id);
    
    if (!deleted) {
      return {
        success: false,
        message: 'ç·¨æˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
      };
    }
    
    return {
      success: true,
      message: 'ç·¨æˆã‚’å‰Šé™¤ã—ã¾ã—ãŸ'
    };
  }
  
  getAllFormations(): PartyFormation[] {
    // Core Engineã‹ã‚‰å…¨ç·¨æˆã‚’å–å¾—
    return this.coreEngine.getAllFormations();
  }
  
  switchToFormation(id: string): FormationSwitchResult {
    const loadResult = this.loadFormation(id);
    if (!loadResult.success || !loadResult.formation) {
      return {
        success: false,
        message: loadResult.message
      };
    }
    
    return {
      success: true,
      message: `ç·¨æˆã€Œ${loadResult.formation.name}ã€ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ`,
      formation: loadResult.formation,
      party: loadResult.formation.members,
      formationPositions: loadResult.formation.formationPositions
    };
  }
}
```

---

## 12. StatusEffectService - çŠ¶æ…‹ç•°å¸¸ãƒ»ãƒãƒ•ç®¡ç†

### æ¦‚è¦
ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®çŠ¶æ…‹ç•°å¸¸ã¨ãƒãƒ•/ãƒ‡ãƒãƒ•ã‚’ç®¡ç†ã€‚ä»˜ä¸ã€è§£é™¤ã€åŠ¹æœé©ç”¨ã€æŒç¶šæ™‚é–“ç®¡ç†ã‚’è¡Œã†ã€‚

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class StatusEffectService {
  // çŠ¶æ…‹ç•°å¸¸ä»˜ä¸
  applyStatusEffect(target: Combatant, effect: StatusEffect, attacker?: Combatant): ApplicationResult;
  
  // çŠ¶æ…‹ç•°å¸¸è§£é™¤
  removeStatusEffect(target: Combatant, effectType: StatusEffectType): RemovalResult;
  
  // ã‚¿ãƒ¼ãƒ³çµŒéå‡¦ç†
  processTurnEffects(target: Combatant): TurnEffectResult;
  
  // è¡Œå‹•åˆ¶é™ãƒã‚§ãƒƒã‚¯
  checkActionRestriction(target: Combatant): ActionRestriction;
}
```

### Core Engine å§”è­²

- `status/effects.checkStatusEffectApplication()` - ä»˜ä¸åˆ¤å®š
- `status/effects.calculateStatusDamage()` - ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
- `status/effects.checkActionRestriction()` - è¡Œå‹•åˆ¶é™åˆ¤å®š
- `status/duration.updateEffectDuration()` - æŒç¶šæ™‚é–“æ›´æ–°
- `status/duration.checkEffectStack()` - ã‚¹ã‚¿ãƒƒã‚¯åˆ¤å®š

### å®Ÿè£…ä¾‹

```typescript
class StatusEffectService {
  constructor(private coreEngine: CoreEngine) {}
  
  applyStatusEffect(target: Combatant, effect: StatusEffect, attacker?: Combatant): ApplicationResult {
    // ä»˜ä¸åˆ¤å®š
    const applicationCheck = this.coreEngine.checkStatusEffectApplication(target, effect, attacker);
    
    if (!applicationCheck.canApply) {
      return {
        success: false,
        message: applicationCheck.reason,
        resisted: true
      };
    }
    
    // ã‚¹ã‚¿ãƒƒã‚¯åˆ¤å®š
    const existingEffect = target.statusEffects.find(e => e.type === effect.type);
    if (existingEffect) {
      const stackCheck = this.coreEngine.checkEffectStack(existingEffect, effect);
      
      if (stackCheck.shouldStack) {
        // ã‚¹ã‚¿ãƒƒã‚¯æ•°ã‚’å¢—ã‚„ã™
        existingEffect.stack = (existingEffect.stack || 1) + 1;
        existingEffect.duration = Math.max(existingEffect.duration, effect.duration);
        
        return {
          success: true,
          message: `${effect.name}ã®åŠ¹æœãŒå¼·åŒ–ã•ã‚Œã¾ã—ãŸï¼ˆ${existingEffect.stack}æ®µéšï¼‰`,
          effect: existingEffect,
          stacked: true
        };
      } else if (stackCheck.shouldRefresh) {
        // æŒç¶šæ™‚é–“ã‚’æ›´æ–°
        existingEffect.duration = effect.duration;
        
        return {
          success: true,
          message: `${effect.name}ã®æŒç¶šæ™‚é–“ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ`,
          effect: existingEffect,
          refreshed: true
        };
      } else {
        return {
          success: false,
          message: `${effect.name}ã¯ã™ã§ã«ä»˜ä¸ã•ã‚Œã¦ã„ã¾ã™`,
          blocked: true
        };
      }
    }
    
    // æ–°è¦ä»˜ä¸
    const newEffect = { ...effect, appliedAt: Date.now(), stack: 1 };
    target.statusEffects.push(newEffect);
    
    return {
      success: true,
      message: `${target.name}ã«${effect.name}ã‚’ä»˜ä¸ã—ã¾ã—ãŸ`,
      effect: newEffect
    };
  }
  
  removeStatusEffect(target: Combatant, effectType: StatusEffectType): RemovalResult {
    const index = target.statusEffects.findIndex(e => e.type === effectType);
    
    if (index === -1) {
      return {
        success: false,
        message: 'åŠ¹æœãŒä»˜ä¸ã•ã‚Œã¦ã„ã¾ã›ã‚“'
      };
    }
    
    const removedEffect = target.statusEffects[index];
    target.statusEffects.splice(index, 1);
    
    return {
      success: true,
      message: `${removedEffect.name}ã‚’è§£é™¤ã—ã¾ã—ãŸ`,
      removedEffect
    };
  }
  
  processTurnEffects(target: Combatant): TurnEffectResult {
    const results: EffectProcessResult[] = [];
    const expiredEffects: StatusEffect[] = [];
    
    for (const effect of target.statusEffects) {
      // ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸/å›å¾©
      if (effect.damagePerTurn || effect.healPerTurn) {
        const damage = this.coreEngine.calculateStatusDamage(target, effect);
        target.currentHp = Math.max(0, Math.min(target.stats.maxHp, target.currentHp - damage));
        
        results.push({
          effect,
          damage: damage > 0 ? damage : undefined,
          heal: damage < 0 ? -damage : undefined
        });
      }
      
      // æŒç¶šæ™‚é–“æ›´æ–°
      effect.duration--;
      
      // åŠ¹æœåˆ‡ã‚Œãƒã‚§ãƒƒã‚¯
      if (effect.duration <= 0) {
        expiredEffects.push(effect);
      }
    }
    
    // åŠ¹æœåˆ‡ã‚Œã®çŠ¶æ…‹ç•°å¸¸ã‚’å‰Šé™¤
    target.statusEffects = target.statusEffects.filter(e => e.duration > 0);
    
    return {
      processedEffects: results,
      expiredEffects,
      remainingEffects: target.statusEffects
    };
  }
  
  checkActionRestriction(target: Combatant): ActionRestriction {
    // Core Engineã§è¡Œå‹•åˆ¶é™ã‚’ãƒã‚§ãƒƒã‚¯
    return this.coreEngine.checkActionRestriction(target);
  }
}
```

---

## 13. CraftService - ã‚¢ã‚¤ãƒ†ãƒ åˆæˆç®¡ç†

### æ¦‚è¦
ã‚¢ã‚¤ãƒ†ãƒ åˆæˆã®æµã‚Œã‚’ç®¡ç†ã€‚ãƒ¬ã‚·ãƒ”ç¢ºèªã€ææ–™ãƒã‚§ãƒƒã‚¯ã€åˆæˆå®Ÿè¡Œã€ãƒ¬ã‚·ãƒ”è§£æ”¾ã‚’è¡Œã†ã€‚

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class CraftService {
  // è§£æ”¾æ¸ˆã¿ãƒ¬ã‚·ãƒ”å–å¾—
  getUnlockedRecipes(gameState: GameState): Recipe[];
  
  // ææ–™ãƒã‚§ãƒƒã‚¯
  checkMaterials(recipe: Recipe, inventory: Inventory): RecipeCheckResult;
  
  // åˆæˆå®Ÿè¡Œ
  synthesize(recipe: Recipe, inventory: Inventory, gameState: GameState): SynthesisResult;
  
  // ãƒ¬ã‚·ãƒ”è§£æ”¾æ¡ä»¶ãƒã‚§ãƒƒã‚¯
  checkRecipeUnlockCondition(recipe: Recipe, gameState: GameState, party: Character[]): boolean;
  
  // ãƒ¬ã‚·ãƒ”è§£æ”¾
  unlockRecipe(recipeId: UniqueId, gameState: GameState, trigger?: string): void;
  
  // æœªè§£æ”¾ãƒ¬ã‚·ãƒ”ã§è§£æ”¾å¯èƒ½ãªã‚‚ã®ã‚’å–å¾—
  getUnlockableRecipes(gameState: GameState, party: Character[]): Recipe[];
}
```

### Core Engine å§”è­²

- `craft/synthesis.checkRecipeRequirements()` - ãƒ¬ã‚·ãƒ”ææ–™ãƒã‚§ãƒƒã‚¯
- `craft/synthesis.calculateSynthesisSuccessRate()` - æˆåŠŸç‡è¨ˆç®—
- `craft/synthesis.rollSynthesisResult()` - åˆæˆçµæœåˆ¤å®š
- `craft/synthesis.calculateMaterialReturn()` - ææ–™è¿”é‚„åˆ¤å®š
- `craft/synthesis.checkRecipeUnlockCondition()` - ãƒ¬ã‚·ãƒ”è§£æ”¾æ¡ä»¶ãƒã‚§ãƒƒã‚¯
- `craft/synthesis.getUnlockedRecipes()` - è§£æ”¾æ¸ˆã¿ãƒ¬ã‚·ãƒ”å–å¾—
- `craft/synthesis.unlockRecipe()` - ãƒ¬ã‚·ãƒ”è§£æ”¾
- `craft/synthesis.checkAllRecipeUnlockConditions()` - å…¨ãƒ¬ã‚·ãƒ”è§£æ”¾å¯å¦ãƒã‚§ãƒƒã‚¯

### å®Ÿè£…ä¾‹

```typescript
class CraftService {
  constructor(
    private coreEngine: CoreEngine,
    private inventoryService: InventoryService
  ) {}
  
  getUnlockedRecipes(gameState: GameState): Recipe[] {
    // Core Engineã§è§£æ”¾æ¸ˆã¿ãƒ¬ã‚·ãƒ”ã‚’å–å¾—
    return this.coreEngine.getUnlockedRecipes(
      this.coreEngine.getAllRecipes(),
      gameState
    );
  }
  
  checkMaterials(recipe: Recipe, inventory: Inventory): RecipeCheckResult {
    // Core Engineã§ææ–™ãƒã‚§ãƒƒã‚¯
    return this.coreEngine.checkRecipeRequirements(recipe, inventory);
  }
  
  checkRecipeUnlockCondition(
    recipe: Recipe,
    gameState: GameState,
    party: Character[]
  ): boolean {
    // ãƒ¬ã‚·ãƒ”è§£æ”¾æ¡ä»¶ã®ãƒã‚§ãƒƒã‚¯
    return this.coreEngine.checkRecipeUnlockCondition(recipe, gameState, party);
  }
  
  unlockRecipe(recipeId: UniqueId, gameState: GameState, trigger?: string): void {
    // ãƒ¬ã‚·ãƒ”ã‚’è§£æ”¾
    this.coreEngine.unlockRecipe(recipeId, gameState, trigger);
    
    // ä½œæˆå›æ•°ã‚’åˆæœŸåŒ–
    if (!gameState.craftHistory.has(recipeId)) {
      gameState.craftHistory.set(recipeId, 0);
    }
  }
  
  getUnlockableRecipes(gameState: GameState, party: Character[]): Recipe[] {
    // æœªè§£æ”¾ã§è§£æ”¾å¯èƒ½ãªãƒ¬ã‚·ãƒ”ã‚’å–å¾—
    const allRecipes = this.coreEngine.getAllRecipes();
    const unlockableRecipes: Recipe[] = [];
    
    for (const recipe of allRecipes) {
      // ã™ã§ã«è§£æ”¾æ¸ˆã¿ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
      if (gameState.unlockedRecipes.has(recipe.id)) {
        continue;
      }
      
      // è§£æ”¾æ¡ä»¶ãƒã‚§ãƒƒã‚¯
      if (this.checkRecipeUnlockCondition(recipe, gameState, party)) {
        unlockableRecipes.push(recipe);
      }
    }
    
    return unlockableRecipes;
  }
  
  synthesize(
    recipe: Recipe,
    inventory: Inventory,
    gameState: GameState
  ): SynthesisResult {
    // ãƒ¬ã‚·ãƒ”è§£æ”¾ãƒã‚§ãƒƒã‚¯
    if (!gameState.unlockedRecipes.has(recipe.id) && !recipe.isUnlockedByDefault) {
      return {
        success: false,
        message: 'ã“ã®ãƒ¬ã‚·ãƒ”ã¯ã¾ã è§£æ”¾ã•ã‚Œã¦ã„ã¾ã›ã‚“',
        outcome: 'failure'
      };
    }
    
    // ææ–™ãƒã‚§ãƒƒã‚¯
    const materialCheck = this.checkMaterials(recipe, inventory);
    if (!materialCheck.canCraft) {
      return {
        success: false,
        message: 'ææ–™ãŒä¸è¶³ã—ã¦ã„ã¾ã™',
        missingMaterials: materialCheck.missingMaterials,
        outcome: 'failure'
      };
    }
    
    // æˆåŠŸç‡è¨ˆç®—
    const successRate = this.coreEngine.calculateSynthesisSuccessRate(recipe);
    
    // åˆæˆåˆ¤å®š
    const result = this.coreEngine.rollSynthesisResult(recipe, successRate);
    
    // ææ–™æ¶ˆè²»
    for (const material of recipe.requiredMaterials) {
      this.inventoryService.removeItem(material.itemId, material.quantity);
    }
    
    // ä½œæˆå›æ•°ã‚’è¨˜éŒ²
    const currentCount = gameState.craftHistory.get(recipe.resultItem.id) || 0;
    gameState.craftHistory.set(recipe.resultItem.id, currentCount + 1);
    
    if (result.outcome === 'success' || result.outcome === 'great-success') {
      // æˆåŠŸï¼šç”Ÿæˆç‰©ã‚’è¿½åŠ 
      const quantity = result.outcome === 'great-success' ? 
        recipe.resultQuantity * 2 : recipe.resultQuantity;
      
      this.inventoryService.addItem(recipe.resultItem.id, quantity);
      
      // ãƒœãƒ¼ãƒŠã‚¹ã‚¢ã‚¤ãƒ†ãƒ 
      if (result.bonusItems && result.bonusItems.length > 0) {
        for (const bonus of result.bonusItems) {
          this.inventoryService.addItem(bonus.item.id, bonus.quantity);
        }
      }
      
      return {
        success: true,
        message: `${recipe.resultItem.name}ã®åˆæˆã«æˆåŠŸã—ã¾ã—ãŸï¼`,
        outcome: result.outcome,
        itemsProduced: [{ item: recipe.resultItem, quantity }],
        bonusItems: result.bonusItems
      };
    } else {
      // å¤±æ•—ï¼šææ–™ã®ä¸€éƒ¨è¿”é‚„åˆ¤å®š
      const returnedMaterials = this.coreEngine.calculateMaterialReturn(recipe);
      for (const material of returnedMaterials) {
        this.inventoryService.addItem(material.item.id, material.quantity);
      }
      
      return {
        success: false,
        message: 'åˆæˆã«å¤±æ•—ã—ã¾ã—ãŸ...',
        outcome: 'failure',
        materialsReturned: returnedMaterials
      };
    }
  }
}
```

### ãƒ¬ã‚·ãƒ”è§£æ”¾æ¡ä»¶ã®ä¾‹

```typescript
// ä¾‹1: ãƒ¬ãƒ™ãƒ«æ¡ä»¶
const basicPotionRecipe: Recipe = {
  id: 'recipe_basic_potion',
  name: 'åŸºæœ¬ãƒãƒ¼ã‚·ãƒ§ãƒ³',
  // ... ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  isUnlockedByDefault: true  // æœ€åˆã‹ã‚‰ä½¿ãˆã‚‹
};

// ä¾‹2: ã‚¯ã‚¨ã‚¹ãƒˆã‚¯ãƒªã‚¢æ¡ä»¶
const advancedPotionRecipe: Recipe = {
  id: 'recipe_advanced_potion',
  name: 'ä¸Šç´šãƒãƒ¼ã‚·ãƒ§ãƒ³',
  // ... ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  unlockCondition: {
    requiredQuest: 'quest_herbalist_training',
    minLevel: 10
  }
};

// ä¾‹3: è¤‡æ•°ã®ä½œæˆå®Ÿç¸¾
const masterPotionRecipe: Recipe = {
  id: 'recipe_master_potion',
  name: 'ãƒã‚¹ã‚¿ãƒ¼ãƒãƒ¼ã‚·ãƒ§ãƒ³',
  // ... ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  unlockCondition: {
    requiredCraftCount: { itemId: 'item_advanced_potion', count: 20 },
    requiredRecipesUnlocked: ['recipe_advanced_potion', 'recipe_herb_essence']
  }
};

// ä¾‹4: ã‚«ã‚¹ã‚¿ãƒ æ¡ä»¶
const legendaryWeaponRecipe: Recipe = {
  id: 'recipe_legendary_sword',
  name: 'ä¼èª¬ã®å‰£',
  // ... ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  unlockCondition: {
    customCondition: (gameState, party) => {
      // ãƒ‘ãƒ¼ãƒ†ã‚£ã«ç‰¹å®šã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒã„ã‚‹
      const hasBlacksmith = party.some(c => c.job.id === 'job_blacksmith');
      // ç‰¹å®šã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‰€æŒã—ã¦ã„ã‚‹
      const hasMythril = gameState.inventory.slots.some(
        slot => slot.item.id === 'item_mythril_ore' && slot.quantity >= 10
      );
      return hasBlacksmith && hasMythril;
    }
  }
};

// ä¾‹5: ORæ¡ä»¶ï¼ˆã„ãšã‚Œã‹ã‚’æº€ãŸã›ã°OKï¼‰
const rareRecipe: Recipe = {
  id: 'recipe_rare_item',
  name: 'ãƒ¬ã‚¢ã‚¢ã‚¤ãƒ†ãƒ ',
  // ... ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  unlockCondition: {
    orConditions: [
      { requiredAchievement: 'achievement_master_crafter' },
      { requiredStoryProgress: 'chapter_5', minLevel: 50 }
    ]
  }
};
```

---

## 14. EnhanceService - è£…å‚™ãƒ»ã‚­ãƒ£ãƒ©å¼·åŒ–

### æ¦‚è¦
è£…å‚™ã‚„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¼·åŒ–ã‚’ç®¡ç†ã€‚å¼·åŒ–å®Ÿè¡Œã€æˆåŠŸåˆ¤å®šã‚’è¡Œã†ã€‚

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class EnhanceService {
  // å¼·åŒ–å®Ÿè¡Œ
  enhance(target: EnhanceTarget, materials: Item[]): EnhanceResult;
  
  // å¼·åŒ–ã‚³ã‚¹ãƒˆè¨ˆç®—
  calculateCost(target: EnhanceTarget, currentLevel: number): EnhanceCost;
  
  // æˆåŠŸç‡å–å¾—
  getSuccessRate(target: EnhanceTarget, currentLevel: number): number;
}
```

### Core Engine å§”è­²

- `craft/enhance.calculateEnhanceSuccessRate()` - æˆåŠŸç‡è¨ˆç®—
- `craft/enhance.rollEnhanceResult()` - å¼·åŒ–çµæœåˆ¤å®š
- `craft/enhance.calculateEnhanceBonus()` - å¼·åŒ–ãƒœãƒ¼ãƒŠã‚¹è¨ˆç®—
- `craft/enhance.calculateEnhanceCost()` - ã‚³ã‚¹ãƒˆè¨ˆç®—

### å®Ÿè£…ä¾‹

```typescript
class EnhanceService {
  constructor(
    private coreEngine: CoreEngine,
    private inventoryService: InventoryService
  ) {}
  
  getSuccessRate(target: EnhanceTarget, currentLevel: number): number {
    // Core Engineã§æˆåŠŸç‡ã‚’è¨ˆç®—
    return this.coreEngine.calculateEnhanceSuccessRate(target, currentLevel);
  }
  
  calculateCost(target: EnhanceTarget, currentLevel: number): EnhanceCost {
    // Core Engineã§ã‚³ã‚¹ãƒˆã‚’è¨ˆç®—
    return this.coreEngine.calculateEnhanceCost(target, currentLevel);
  }
  
  enhance(target: EnhanceTarget, materials: Item[]): EnhanceResult {
    const currentLevel = target.enhanceLevel || 0;
    
    // ã‚³ã‚¹ãƒˆè¨ˆç®—
    const cost = this.calculateCost(target, currentLevel);
    
    // ææ–™ãƒã‚§ãƒƒã‚¯
    for (const material of cost.requiredMaterials) {
      if (!this.inventoryService.hasItem(material.item.id, material.quantity)) {
        return {
          success: false,
          failed: false,
          message: `${material.item.name}ãŒä¸è¶³ã—ã¦ã„ã¾ã™`
        };
      }
    }
    
    // ãŠé‡‘ãƒã‚§ãƒƒã‚¯
    // if (gameState.money < cost.money) {
    //   return { success: false, failed: false, message: 'ãŠé‡‘ãŒä¸è¶³ã—ã¦ã„ã¾ã™' };
    // }
    
    // æˆåŠŸç‡å–å¾—
    const successRate = this.getSuccessRate(target, currentLevel);
    
    // ææ–™ãƒ»ãŠé‡‘æ¶ˆè²»
    for (const material of cost.requiredMaterials) {
      this.inventoryService.removeItem(material.item, material.quantity);
    }
    // gameState.money -= cost.money;
    
    // å¼·åŒ–åˆ¤å®š
    const result = this.coreEngine.rollEnhanceResult(target, successRate);
    
    if (result.success) {
      // æˆåŠŸï¼šå¼·åŒ–ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
      const previousLevel = currentLevel;
      target.enhanceLevel = currentLevel + 1;
      
      // ãƒœãƒ¼ãƒŠã‚¹è¨ˆç®—
      const bonus = this.coreEngine.calculateEnhanceBonus(target, target.enhanceLevel);
      
      // è£…å‚™ã®å ´åˆã¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°
      if ('stats' in target) {
        (target as Equipment).stats = {
          ...((target as Equipment).stats || {}),
          attack: ((target as Equipment).stats?.attack || 0) + (bonus.attack || 0),
          defense: ((target as Equipment).stats?.defense || 0) + (bonus.defense || 0),
          magicAttack: ((target as Equipment).stats?.magicAttack || 0) + (bonus.magicAttack || 0),
          magicDefense: ((target as Equipment).stats?.magicDefense || 0) + (bonus.magicDefense || 0)
        };
      }
      
      return {
        success: true,
        failed: false,
        message: `å¼·åŒ–ã«æˆåŠŸã—ã¾ã—ãŸï¼ +${target.enhanceLevel}`,
        newLevel: target.enhanceLevel,
        previousLevel,
        bonus,
        wasGreatSuccess: result.wasGreatSuccess
      };
    } else {
      // å¤±æ•—
      if (result.destroyed) {
        // ç ´å£Š
        // target ã‚’å‰Šé™¤ã™ã‚‹å‡¦ç†ãŒå¿…è¦
        return {
          success: false,
          failed: true,
          destroyed: true,
          message: 'å¼·åŒ–ã«å¤±æ•—ã—ã€è£…å‚™ãŒç ´å£Šã•ã‚Œã¾ã—ãŸ...'
        };
      } else if (result.levelDown) {
        // ãƒ¬ãƒ™ãƒ«ãƒ€ã‚¦ãƒ³
        const previousLevel = currentLevel;
        target.enhanceLevel = Math.max(0, currentLevel - 1);
        
        return {
          success: false,
          failed: true,
          levelDown: true,
          message: `å¼·åŒ–ã«å¤±æ•—ã—ã€å¼·åŒ–ãƒ¬ãƒ™ãƒ«ãŒä¸‹ãŒã‚Šã¾ã—ãŸï¼ˆ+${previousLevel} â†’ +${target.enhanceLevel}ï¼‰`,
          newLevel: target.enhanceLevel,
          previousLevel
        };
      } else {
        // å¤±æ•—ï¼ˆãƒ¬ãƒ™ãƒ«ç¶­æŒï¼‰
        return {
          success: false,
          failed: true,
          message: 'å¼·åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸãŒã€å¼·åŒ–ãƒ¬ãƒ™ãƒ«ã¯ç¶­æŒã•ã‚Œã¾ã—ãŸ'
        };
      }
    }
  }
}
```

---

## 15. SaveLoadService - ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰ç®¡ç†

### æ¦‚è¦
ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’ã‚»ãƒ¼ãƒ–ãƒ»ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã€‚ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã€ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã‚’è¡Œã†ã€‚

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class SaveLoadService {
  // ã‚»ãƒ¼ãƒ–
  save(slot: number, gameState: GameState): Promise<SaveResult>;
  
  // ãƒ­ãƒ¼ãƒ‰
  load(slot: number): Promise<GameState>;
  
  // ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ä¸€è¦§
  listSaves(): SaveData[];
  
  // ã‚»ãƒ¼ãƒ–å‰Šé™¤
  deleteSave(slot: number): Promise<void>;
}
```

### å®Ÿè£…ä¾‹

```typescript
class SaveLoadService {
  constructor(private storageAdapter: StorageAdapter) {}
  
  async save(slot: number, gameState: GameState): Promise<SaveResult> {
    try {
      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
      const saveData: SaveData = {
        slot,
        version: '1.0.0',
        timestamp: Date.now(),
        playtime: gameState.playtime,
        location: gameState.currentLocation,
        partyLevel: Math.floor(
          gameState.party.reduce((sum, c) => sum + c.level, 0) / gameState.party.length
        ),
        data: JSON.stringify(gameState)
      };
      
      // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
      await this.storageAdapter.write(`save_${slot}`, saveData);
      
      return {
        success: true,
        message: 'ã‚»ãƒ¼ãƒ–ã—ã¾ã—ãŸ',
        saveData
      };
    } catch (error) {
      return {
        success: false,
        message: `ã‚»ãƒ¼ãƒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`
      };
    }
  }
  
  async load(slot: number): Promise<GameState> {
    try {
      // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰èª­ã¿è¾¼ã¿
      const saveData = await this.storageAdapter.read<SaveData>(`save_${slot}`);
      
      if (!saveData) {
        throw new Error('ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      }
      
      // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯
      if (saveData.version !== '1.0.0') {
        // ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
        console.warn(`æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿: ${saveData.version}`);
      }
      
      // ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
      const gameState: GameState = JSON.parse(saveData.data);
      
      return gameState;
    } catch (error) {
      throw new Error(`ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }
  }
  
  listSaves(): SaveData[] {
    const saves: SaveData[] = [];
    
    // å…¨ã‚¹ãƒ­ãƒƒãƒˆã‚’ãƒã‚§ãƒƒã‚¯
    for (let slot = 1; slot <= 10; slot++) {
      try {
        const saveData = this.storageAdapter.readSync<SaveData>(`save_${slot}`);
        if (saveData) {
          // ãƒ‡ãƒ¼ã‚¿æœ¬ä½“ã¯å«ã‚ãªã„ï¼ˆã‚µã‚¤ã‚ºå‰Šæ¸›ï¼‰
          saves.push({
            ...saveData,
            data: ''
          });
        }
      } catch (error) {
        // ã‚¹ãƒ­ãƒƒãƒˆãŒç©ºã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
      }
    }
    
    return saves;
  }
  
  async deleteSave(slot: number): Promise<void> {
    await this.storageAdapter.delete(`save_${slot}`);
  }
}

// ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
interface StorageAdapter {
  write<T>(key: string, data: T): Promise<void>;
  read<T>(key: string): Promise<T | null>;
  readSync<T>(key: string): T | null;
  delete(key: string): Promise<void>;
}
```

---

## 16. SimulationService - æˆ¦é—˜ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

### æ¦‚è¦
æˆ¦é—˜çµæœã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ã€å‹ç‡ã‚„æœŸå¾…ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¨ˆç®—ã€‚

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class SimulationService {
  // æˆ¦é—˜ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
  simulateBattle(party: Character[], enemies: Enemy[], iterations: number): SimulationResult;
  
  // ãƒ€ãƒ¡ãƒ¼ã‚¸æœŸå¾…å€¤è¨ˆç®—
  calculateExpectedDamage(attacker: Combatant, target: Combatant, skill: Skill): number;
  
  // å‹ç‡è¨ˆç®—
  calculateWinRate(party: Character[], enemies: Enemy[]): number;
}
```

### Core Engine å§”è­²
- ã»ã¼ã™ã¹ã¦ã®Core Engineæ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦æˆ¦é—˜ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ

### å®Ÿè£…ä¾‹

```typescript
class SimulationService {
  constructor(private coreEngine: CoreEngine) {}
  
  simulateBattle(party: Character[], enemies: Enemy[], iterations: number = 1000): SimulationResult {
    let victories = 0;
    let defeats = 0;
    let totalTurns = 0;
    const damageDealt: number[] = [];
    const damageTaken: number[] = [];
    
    for (let i = 0; i < iterations; i++) {
      // ãƒ‘ãƒ¼ãƒ†ã‚£ã¨æ•µã®ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆ
      const partyCopy = party.map(c => ({ ...c, currentHp: c.stats.maxHp, currentMp: c.stats.maxMp }));
      const enemiesCopy = enemies.map(e => ({ ...e, currentHp: e.stats.maxHp, currentMp: e.stats.maxMp }));
      
      // 1å›ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
      const battleResult = this.simulateSingleBattle(partyCopy, enemiesCopy);
      
      if (battleResult.victory) {
        victories++;
      } else {
        defeats++;
      }
      
      totalTurns += battleResult.turns;
      damageDealt.push(battleResult.totalDamageDealt);
      damageTaken.push(battleResult.totalDamageTaken);
    }
    
    return {
      winRate: victories / iterations,
      averageTurns: totalTurns / iterations,
      averageDamageDealt: damageDealt.reduce((a, b) => a + b, 0) / iterations,
      averageDamageTaken: damageTaken.reduce((a, b) => a + b, 0) / iterations,
      iterations
    };
  }
  
  private simulateSingleBattle(party: Character[], enemies: Enemy[]): SingleBattleResult {
    let turns = 0;
    let totalDamageDealt = 0;
    let totalDamageTaken = 0;
    const maxTurns = 100; // ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢
    
    while (turns < maxTurns) {
      turns++;
      
      // ã‚¿ãƒ¼ãƒ³é †åºè¨ˆç®—
      const turnOrder = this.coreEngine.calculateTurnOrder([...party, ...enemies]);
      
      for (const combatant of turnOrder) {
        // è¡Œå‹•ä¸èƒ½ãƒã‚§ãƒƒã‚¯
        const canAct = this.coreEngine.checkCanAct(combatant);
        if (!canAct) continue;
        
        // è¡Œå‹•é¸æŠ
        let action: BattleAction;
        if ('aiStrategy' in combatant) {
          // æ•µã®è¡Œå‹•
          const targets = party.filter(c => c.currentHp > 0);
          if (targets.length === 0) break;
          
          const skill = combatant.skills[Math.floor(Math.random() * combatant.skills.length)];
          action = {
            actor: combatant as Enemy,
            type: 'skill',
            skill,
            targets: [targets[Math.floor(Math.random() * targets.length)]]
          };
        } else {
          // å‘³æ–¹ã®è¡Œå‹•ï¼ˆç°¡æ˜“AIï¼‰
          const targets = enemies.filter(e => e.currentHp > 0);
          if (targets.length === 0) break;
          
          const skill = combatant.skills[0] || { type: 'physical-attack' };
          action = {
            actor: combatant as Character,
            type: 'skill',
            skill,
            targets: [targets[0]]
          };
        }
        
        // è¡Œå‹•å®Ÿè¡Œ
        const result = this.coreEngine.executeAction(action);
        
        // ãƒ€ãƒ¡ãƒ¼ã‚¸é›†è¨ˆ
        if ('aiStrategy' in combatant) {
          totalDamageTaken += result.totalDamage || 0;
        } else {
          totalDamageDealt += result.totalDamage || 0;
        }
        
        // å‹æ•—åˆ¤å®š
        const aliveParty = party.filter(c => c.currentHp > 0).length;
        const aliveEnemies = enemies.filter(e => e.currentHp > 0).length;
        
        if (aliveEnemies === 0) {
          return {
            victory: true,
            turns,
            totalDamageDealt,
            totalDamageTaken
          };
        }
        
        if (aliveParty === 0) {
          return {
            victory: false,
            turns,
            totalDamageDealt,
            totalDamageTaken
          };
        }
      }
    }
    
    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆå¼•ãåˆ†ã‘æ‰±ã„ï¼‰
    return {
      victory: false,
      turns,
      totalDamageDealt,
      totalDamageTaken
    };
  }
  
  calculateExpectedDamage(attacker: Combatant, target: Combatant, skill: Skill): number {
    // Core Engineã§æœŸå¾…ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¨ˆç®—
    return this.coreEngine.calculateExpectedDamage(attacker, target, skill);
  }
  
  calculateWinRate(party: Character[], enemies: Enemy[]): number {
    // ç°¡æ˜“ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ100å›ï¼‰
    const result = this.simulateBattle(party, enemies, 100);
    return result.winRate;
  }
}

interface SingleBattleResult {
  victory: boolean;
  turns: number;
  totalDamageDealt: number;
  totalDamageTaken: number;
}
```

---

## ã¾ã¨ã‚

### Serviceå®Ÿè£…ã®å„ªå…ˆé †ä½

**ãƒ•ã‚§ãƒ¼ã‚º1: æˆ¦é—˜ã®åŸºç¤**
1. BattleService
2. CommandService
3. EnemyAIService
4. EnemyGroupService
5. StatusEffectService

**ãƒ•ã‚§ãƒ¼ã‚º2: æˆé•·ã¨ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º**
6. RewardService
7. EquipmentService
8. PartyService
9. SkillLearnService
10. JobChangeService

**ãƒ•ã‚§ãƒ¼ã‚º3: ç™ºå±•çš„æ©Ÿèƒ½**
11. ItemService
12. CraftService
13. EnhanceService
14. SaveLoadService
15. SimulationService

### Serviceé–“ã®ä¾å­˜é–¢ä¿‚

```
BattleService
â”œâ”€depends onâ†’ CommandService
â”œâ”€depends onâ†’ EnemyAIService
â”œâ”€depends onâ†’ StatusEffectService
â””â”€depends onâ†’ RewardService (æˆ¦é—˜çµ‚äº†æ™‚)

RewardService
â””â”€depends onâ†’ SkillLearnService (ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ™‚)

CommandService
â””â”€depends onâ†’ ItemService (ã‚¢ã‚¤ãƒ†ãƒ é¸æŠæ™‚)

PartyService
â””â”€depends onâ†’ EquipmentService (ãƒ¡ãƒ³ãƒãƒ¼å¤‰æ›´æ™‚)
```

### å…±é€šè¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³

ã™ã¹ã¦ã®Serviceã¯ä»¥ä¸‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¾“ã„ã¾ã™ï¼š

1. **çŠ¶æ…‹ç®¡ç†**: ç¾åœ¨ã®å‡¦ç†æ®µéšã‚’ä¿æŒ
2. **Core Engineå§”è­²**: è¨ˆç®—ã¨ãƒ«ãƒ¼ãƒ«åˆ¤å®šã¯Core Engineã«å§”è­²
3. **å‹å®‰å…¨**: TypeScriptã®å‹ã‚·ã‚¹ãƒ†ãƒ ã‚’æ´»ç”¨
4. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: ä¸æ­£ãªçŠ¶æ…‹é·ç§»ã‚’é˜²ã
5. **ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£**: ä¾å­˜æ³¨å…¥ã«ã‚ˆã‚Šãƒ†ã‚¹ãƒˆå®¹æ˜“

ã“ã®è¨­è¨ˆã«ã‚ˆã‚Šã€GEasy-Kitãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®15ã®Serviceã‚’ä¸€è²«æ€§ã‚’æŒã£ã¦å®Ÿè£…ã§ãã¾ã™ã€‚
