# ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ

ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ã¨èª­ã¿è¾¼ã¿ã«é–¢ã™ã‚‹è¨­è¨ˆã€‚Core Engineã€Serviceã€Headless UIã®3å±¤ã§æ§‹æˆã€‚

## ç›®æ¬¡

1. [æ¦‚è¦](#æ¦‚è¦)
2. [Core Engineå±¤](#core-engineå±¤)
3. [Serviceå±¤](#serviceå±¤)
4. [Headless UIå±¤](#headless-uiå±¤)

---

## æ¦‚è¦

### 3å±¤ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Headless UI Layer                  â”‚
â”‚  Controller                         â”‚  â† UIçŠ¶æ…‹ç®¡ç†ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ å§”è­²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Service Layer                      â”‚
â”‚  Service                            â”‚  â† ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ å§”è­²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Core Engine Layer                  â”‚
â”‚  ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«                          â”‚  â† ç´”ç²‹ãªè¨ˆç®—
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Core Engineå±¤

### ğŸ’¾ æ°¸ç¶šåŒ–ã¨æ•´åˆæ€§

#### ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®æ°¸ç¶šåŒ–
- çŠ¶æ…‹ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
  - Game Stateã®æ°¸ç¶šåŒ–å½¢å¼ã¸ã®å¤‰æ›
  - ãƒ‡ãƒ¼ã‚¿ã®åœ§ç¸®
- ãƒ‡ãƒ¼ã‚¿ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†
  - ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã®ç®¡ç†
  - äº’æ›æ€§ã®ãƒã‚§ãƒƒã‚¯
  - ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†


---

## Serviceå±¤

---

## 15. SaveLoadService - ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰ç®¡ç†

### æ¦‚è¦
ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’ã‚»ãƒ¼ãƒ–ãƒ»ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã€‚ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã€ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã‚’è¡Œã†ã€‚

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class SaveLoadService {
  // ã‚»ãƒ¼ãƒ–
  save(slot: number, gameState: GameState): Promise<SaveResult>;
  
  // ãƒ­ãƒ¼ãƒ‰
  load(slot: number): Promise<GameState>;
  
  // ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ä¸€è¦§
  listSaves(): SaveData[];
  
  // ã‚»ãƒ¼ãƒ–å‰Šé™¤
  deleteSave(slot: number): Promise<void>;
}
```

### å®Ÿè£…ä¾‹

```typescript
class SaveLoadService {
  constructor(private storageAdapter: StorageAdapter) {}
  
  async save(slot: number, gameState: GameState): Promise<SaveResult> {
    try {
      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
      const saveData: SaveData = {
        slot,
        version: '1.0.0',
        timestamp: Date.now(),
        playtime: gameState.playtime,
        location: gameState.currentLocation,
        partyLevel: Math.floor(
          gameState.party.reduce((sum, c) => sum + c.level, 0) / gameState.party.length
        ),
        data: JSON.stringify(gameState)
      };
      
      // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
      await this.storageAdapter.write(`save_${slot}`, saveData);
      
      return {
        success: true,
        message: 'ã‚»ãƒ¼ãƒ–ã—ã¾ã—ãŸ',
        saveData
      };
    } catch (error) {
      return {
        success: false,
        message: `ã‚»ãƒ¼ãƒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`
      };
    }
  }
  
  async load(slot: number): Promise<GameState> {
    try {
      // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰èª­ã¿è¾¼ã¿
      const saveData = await this.storageAdapter.read<SaveData>(`save_${slot}`);
      
      if (!saveData) {
        throw new Error('ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      }
      
      // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯
      if (saveData.version !== '1.0.0') {
        // ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
        console.warn(`æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿: ${saveData.version}`);
      }
      
      // ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
      const gameState: GameState = JSON.parse(saveData.data);
      
      return gameState;
    } catch (error) {
      throw new Error(`ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }
  }
  
  listSaves(): SaveData[] {
    const saves: SaveData[] = [];
    
    // å…¨ã‚¹ãƒ­ãƒƒãƒˆã‚’ãƒã‚§ãƒƒã‚¯
    for (let slot = 1; slot <= 10; slot++) {
      try {
        const saveData = this.storageAdapter.readSync<SaveData>(`save_${slot}`);
        if (saveData) {
          // ãƒ‡ãƒ¼ã‚¿æœ¬ä½“ã¯å«ã‚ãªã„ï¼ˆã‚µã‚¤ã‚ºå‰Šæ¸›ï¼‰
          saves.push({
            ...saveData,
            data: ''
          });
        }
      } catch (error) {
        // ã‚¹ãƒ­ãƒƒãƒˆãŒç©ºã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
      }
    }
    
    return saves;
  }
  
  async deleteSave(slot: number): Promise<void> {
    await this.storageAdapter.delete(`save_${slot}`);
  }
}

// ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
interface StorageAdapter {
  write<T>(key: string, data: T): Promise<void>;
  read<T>(key: string): Promise<T | null>;
  readSync<T>(key: string): T | null;
  delete(key: string): Promise<void>;
}
```



---

## Headless UIå±¤

---

## 11. SaveLoadController - ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰UIåˆ¶å¾¡

### çŠ¶æ…‹å®šç¾©

```typescript
interface SaveLoadUIState {
  // ãƒ¢ãƒ¼ãƒ‰
  mode: 'save' | 'load';
  
  // æ®µéš
  stage: 'selecting-slot' | 'confirming' | 'processing' | 'completed';
  
  // ã‚»ãƒ¼ãƒ–ã‚¹ãƒ­ãƒƒãƒˆ
  saveSlots: SaveSlotInfo[];
  selectedSlot: number | null;
  
  // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
  currentGameState: GameState | null;
  
  // çµæœ
  result: SaveLoadResult | null;
  isProcessing: boolean;
  
  // ã‚¨ãƒ©ãƒ¼
  error: string | null;
  
  // ã‚«ãƒ¼ã‚½ãƒ«
  cursorIndex: number;
}

interface SaveSlotInfo {
  slot: number;
  exists: boolean;
  saveData?: {
    timestamp: number;
    playTime: number;
    location: string;
    partyLevel: number;
    characters: { name: string; level: number }[];
  };
}

interface SaveLoadResult {
  success: boolean;
  slot: number;
  message: string;
}
```

### ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼å®Ÿè£…

```typescript
type SaveLoadEvents = {
  'slot-selected': { slot: number };
  'save-completed': { result: SaveLoadResult };
  'load-completed': { result: SaveLoadResult; gameState: GameState };
  'cancelled': {};
};

class SaveLoadController {
  private state: ObservableState<SaveLoadUIState>;
  private events: EventEmitter<SaveLoadEvents>;
  private service: SaveLoadService;
  
  constructor(service: SaveLoadService) {
    this.service = service;
    this.state = new ObservableState<SaveLoadUIState>({
      mode: 'save',
      stage: 'selecting-slot',
      saveSlots: [],
      selectedSlot: null,
      currentGameState: null,
      result: null,
      isProcessing: false,
      error: null,
      cursorIndex: 0
    });
    this.events = new EventEmitter<SaveLoadEvents>();
  }
  
  subscribe(listener: (state: SaveLoadUIState) => void): () => void {
    return this.state.subscribe(listener);
  }
  
  on<K extends keyof SaveLoadEvents>(
    event: K,
    listener: (data: SaveLoadEvents[K]) => void
  ): () => void {
    return this.events.on(event, listener);
  }
  
  // ã‚»ãƒ¼ãƒ–ãƒ¢ãƒ¼ãƒ‰é–‹å§‹
  startSave(gameState: GameState): void {
    const saveSlots = this.loadSaveSlots();
    
    this.state.setState({
      mode: 'save',
      stage: 'selecting-slot',
      saveSlots,
      selectedSlot: null,
      currentGameState: gameState,
      result: null,
      isProcessing: false,
      error: null,
      cursorIndex: 0
    });
  }
  
  // ãƒ­ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰é–‹å§‹
  startLoad(): void {
    const saveSlots = this.loadSaveSlots();
    
    this.state.setState({
      mode: 'load',
      stage: 'selecting-slot',
      saveSlots,
      selectedSlot: null,
      currentGameState: null,
      result: null,
      isProcessing: false,
      error: null,
      cursorIndex: 0
    });
  }
  
  // ã‚¹ãƒ­ãƒƒãƒˆé¸æŠ
  selectSlot(slot: number): void {
    this.state.setState(prev => ({
      ...prev,
      selectedSlot: slot
    }));
    
    this.events.emit('slot-selected', { slot });
  }
  
  // ç¢ºèªç”»é¢ã¸
  moveToConfirming(): void {
    this.state.setState(prev => ({
      ...prev,
      stage: 'confirming'
    }));
  }
  
  // ã‚»ãƒ¼ãƒ–å®Ÿè¡Œ
  async save(): Promise<void> {
    const slot = this.state.getState().selectedSlot!;
    const gameState = this.state.getState().currentGameState!;
    
    this.state.setState(prev => ({
      ...prev,
      stage: 'processing',
      isProcessing: true,
      error: null
    }));
    
    try {
      const result = await this.service.save(slot, gameState);
      
      this.state.setState(prev => ({
        ...prev,
        stage: 'completed',
        result: result as SaveLoadResult,
        isProcessing: false,
        saveSlots: this.loadSaveSlots() // ãƒªãƒ­ãƒ¼ãƒ‰
      }));
      
      this.events.emit('save-completed', { result: result as SaveLoadResult });
    } catch (error) {
      this.state.setState(prev => ({
        ...prev,
        stage: 'selecting-slot',
        isProcessing: false,
        error: (error as Error).message
      }));
    }
  }
  
  // ãƒ­ãƒ¼ãƒ‰å®Ÿè¡Œ
  async load(): Promise<void> {
    const slot = this.state.getState().selectedSlot!;
    
    this.state.setState(prev => ({
      ...prev,
      stage: 'processing',
      isProcessing: true,
      error: null
    }));
    
    try {
      const gameState = await this.service.load(slot);
      
      this.state.setState(prev => ({
        ...prev,
        stage: 'completed',
        currentGameState: gameState,
        isProcessing: false,
        result: {
          success: true,
          slot,
          message: 'ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ'
        }
      }));
      
      this.events.emit('load-completed', {
        result: { success: true, slot, message: 'ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ' },
        gameState
      });
    } catch (error) {
      this.state.setState(prev => ({
        ...prev,
        stage: 'selecting-slot',
        isProcessing: false,
        error: (error as Error).message
      }));
    }
  }
  
  // ã‚»ãƒ¼ãƒ–å‰Šé™¤
  async deleteSave(slot: number): Promise<void> {
    try {
      await this.service.deleteSave(slot);
      
      // ã‚¹ãƒ­ãƒƒãƒˆæƒ…å ±ãƒªãƒ­ãƒ¼ãƒ‰
      this.state.setState(prev => ({
        ...prev,
        saveSlots: this.loadSaveSlots()
      }));
    } catch (error) {
      this.state.setState(prev => ({
        ...prev,
        error: (error as Error).message
      }));
    }
  }
  
  // ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•
  moveCursor(delta: number): void {
    const maxIndex = this.state.getState().saveSlots.length - 1;
    const currentIndex = this.state.getState().cursorIndex;
    const newIndex = Math.max(0, Math.min(maxIndex, currentIndex + delta));
    
    this.state.setState(prev => ({
      ...prev,
      cursorIndex: newIndex
    }));
  }
  
  // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  cancel(): void {
    const currentState = this.state.getState();
    
    if (currentState.stage === 'confirming') {
      this.state.setState(prev => ({
        ...prev,
        stage: 'selecting-slot'
      }));
    } else {
      this.events.emit('cancelled', {});
    }
  }
  
  // ã‚»ãƒ¼ãƒ–ã‚¹ãƒ­ãƒƒãƒˆæƒ…å ±èª­ã¿è¾¼ã¿
  private loadSaveSlots(): SaveSlotInfo[] {
    const saves = this.service.listSaves();
    const slots: SaveSlotInfo[] = [];
    
    for (let i = 0; i < 10; i++) {
      const saveData = saves.find(s => s.slot === i);
      slots.push({
        slot: i,
        exists: !!saveData,
        saveData: saveData ? {
          timestamp: saveData.timestamp,
          playTime: saveData.playTime,
          location: saveData.location,
          partyLevel: saveData.partyLevel,
          characters: saveData.characters
        } : undefined
      });
    }
    
    return slots;
  }
}
```


