# çŠ¶æ…‹ç•°å¸¸ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ

çŠ¶æ…‹ç•°å¸¸ã¨ãƒãƒ•ãƒ»ãƒ‡ãƒãƒ•ã®ç®¡ç†ã«é–¢ã™ã‚‹è¨­è¨ˆã€‚Core Engineã€Serviceã€Headless UIã®3å±¤ã§æ§‹æˆã€‚

## ç›®æ¬¡

1. [æ¦‚è¦](#æ¦‚è¦)
2. [Core Engineå±¤](#core-engineå±¤)
3. [Serviceå±¤](#serviceå±¤)
4. [Headless UIå±¤](#headless-uiå±¤)

---

## æ¦‚è¦

### 3å±¤ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Headless UI Layer                  â”‚
â”‚  Controller                         â”‚  â† UIçŠ¶æ…‹ç®¡ç†ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ å§”è­²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Service Layer                      â”‚
â”‚  Service                            â”‚  â† ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ å§”è­²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Core Engine Layer                  â”‚
â”‚  ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«                          â”‚  â† ç´”ç²‹ãªè¨ˆç®—
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Core Engineå±¤

### ğŸ’« çŠ¶æ…‹ç•°å¸¸ãƒ»ãƒãƒ•ãƒ»ãƒ‡ãƒãƒ•ã«é–¢ã™ã‚‹è¨ˆç®—

#### çŠ¶æ…‹ç•°å¸¸ã®ä»˜ä¸åˆ¤å®š
- çŠ¶æ…‹ç•°å¸¸ã®ä»˜ä¸åˆ¤å®š
  - åŸºæœ¬æˆåŠŸç‡
  - è€æ€§ã«ã‚ˆã‚‹è»½æ¸›
  - ç¢ºç‡è¨ˆç®—
- åŠ¹æœã®è¨ˆç®—
  - æ¯’ãƒ€ãƒ¡ãƒ¼ã‚¸ãªã©ã®ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸
  - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰å‹•ã®è¨ˆç®—
  - è¡Œå‹•åˆ¶é™ã®åˆ¤å®š
- è§£é™¤æ¡ä»¶ã®åˆ¤å®š
  - ã‚¿ãƒ¼ãƒ³çµŒéã«ã‚ˆã‚‹è‡ªç„¶è§£é™¤
  - ã‚¢ã‚¤ãƒ†ãƒ ãƒ»ã‚¹ã‚­ãƒ«ã«ã‚ˆã‚‹è§£é™¤
  - ç‰¹å®šæ¡ä»¶ã§ã®è‡ªå‹•è§£é™¤

#### ãƒãƒ•ãƒ»ãƒ‡ãƒãƒ•ã®è¨ˆç®—
- åŠ¹æœé‡ã®è¨ˆç®—
  - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ä¸Šæ˜‡/ä¸‹é™ã®å€ç‡
  - é‡è¤‡æ™‚ã®å‡¦ç†
  - ã‚¹ã‚¿ãƒƒã‚¯ä¸Šé™
- æŒç¶šæ™‚é–“ã®ç®¡ç†
  - æ®‹ã‚Šã‚¿ãƒ¼ãƒ³æ•°ã®è¨ˆç®—
  - åŠ¹æœã®å»¶é•·ãƒ»çŸ­ç¸®


---

## Serviceå±¤

---

## 12. StatusEffectService - çŠ¶æ…‹ç•°å¸¸ãƒ»ãƒãƒ•ç®¡ç†

### æ¦‚è¦
ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®çŠ¶æ…‹ç•°å¸¸ã¨ãƒãƒ•/ãƒ‡ãƒãƒ•ã‚’ç®¡ç†ã€‚ä»˜ä¸ã€è§£é™¤ã€åŠ¹æœé©ç”¨ã€æŒç¶šæ™‚é–“ç®¡ç†ã‚’è¡Œã†ã€‚

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class StatusEffectService {
  // çŠ¶æ…‹ç•°å¸¸ä»˜ä¸
  applyStatusEffect(target: Combatant, effect: StatusEffect, attacker?: Combatant): ApplicationResult;
  
  // çŠ¶æ…‹ç•°å¸¸è§£é™¤
  removeStatusEffect(target: Combatant, effectType: StatusEffectType): RemovalResult;
  
  // ã‚¿ãƒ¼ãƒ³çµŒéå‡¦ç†
  processTurnEffects(target: Combatant): TurnEffectResult;
  
  // è¡Œå‹•åˆ¶é™ãƒã‚§ãƒƒã‚¯
  checkActionRestriction(target: Combatant): ActionRestriction;
}
```

### Core Engine å§”è­²

- `status/effects.checkStatusEffectApplication()` - ä»˜ä¸åˆ¤å®š
- `status/effects.calculateStatusDamage()` - ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
- `status/effects.checkActionRestriction()` - è¡Œå‹•åˆ¶é™åˆ¤å®š
- `status/duration.updateEffectDuration()` - æŒç¶šæ™‚é–“æ›´æ–°
- `status/duration.checkEffectStack()` - ã‚¹ã‚¿ãƒƒã‚¯åˆ¤å®š

### å®Ÿè£…ä¾‹

```typescript
class StatusEffectService {
  constructor(private coreEngine: CoreEngine) {}
  
  applyStatusEffect(target: Combatant, effect: StatusEffect, attacker?: Combatant): ApplicationResult {
    // ä»˜ä¸åˆ¤å®š
    const applicationCheck = this.coreEngine.checkStatusEffectApplication(target, effect, attacker);
    
    if (!applicationCheck.canApply) {
      return {
        success: false,
        message: applicationCheck.reason,
        resisted: true
      };
    }
    
    // ã‚¹ã‚¿ãƒƒã‚¯åˆ¤å®š
    const existingEffect = target.statusEffects.find(e => e.type === effect.type);
    if (existingEffect) {
      const stackCheck = this.coreEngine.checkEffectStack(existingEffect, effect);
      
      if (stackCheck.shouldStack) {
        // ã‚¹ã‚¿ãƒƒã‚¯æ•°ã‚’å¢—ã‚„ã™
        existingEffect.stack = (existingEffect.stack || 1) + 1;
        existingEffect.duration = Math.max(existingEffect.duration, effect.duration);
        
        return {
          success: true,
          message: `${effect.name}ã®åŠ¹æœãŒå¼·åŒ–ã•ã‚Œã¾ã—ãŸï¼ˆ${existingEffect.stack}æ®µéšï¼‰`,
          effect: existingEffect,
          stacked: true
        };
      } else if (stackCheck.shouldRefresh) {
        // æŒç¶šæ™‚é–“ã‚’æ›´æ–°
        existingEffect.duration = effect.duration;
        
        return {
          success: true,
          message: `${effect.name}ã®æŒç¶šæ™‚é–“ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ`,
          effect: existingEffect,
          refreshed: true
        };
      } else {
        return {
          success: false,
          message: `${effect.name}ã¯ã™ã§ã«ä»˜ä¸ã•ã‚Œã¦ã„ã¾ã™`,
          blocked: true
        };
      }
    }
    
    // æ–°è¦ä»˜ä¸
    const newEffect = { ...effect, appliedAt: Date.now(), stack: 1 };
    target.statusEffects.push(newEffect);
    
    return {
      success: true,
      message: `${target.name}ã«${effect.name}ã‚’ä»˜ä¸ã—ã¾ã—ãŸ`,
      effect: newEffect
    };
  }
  
  removeStatusEffect(target: Combatant, effectType: StatusEffectType): RemovalResult {
    const index = target.statusEffects.findIndex(e => e.type === effectType);
    
    if (index === -1) {
      return {
        success: false,
        message: 'åŠ¹æœãŒä»˜ä¸ã•ã‚Œã¦ã„ã¾ã›ã‚“'
      };
    }
    
    const removedEffect = target.statusEffects[index];
    target.statusEffects.splice(index, 1);
    
    return {
      success: true,
      message: `${removedEffect.name}ã‚’è§£é™¤ã—ã¾ã—ãŸ`,
      removedEffect
    };
  }
  
  processTurnEffects(target: Combatant): TurnEffectResult {
    const results: EffectProcessResult[] = [];
    const expiredEffects: StatusEffect[] = [];
    
    for (const effect of target.statusEffects) {
      // ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸/å›å¾©
      if (effect.damagePerTurn || effect.healPerTurn) {
        const damage = this.coreEngine.calculateStatusDamage(target, effect);
        target.currentHp = Math.max(0, Math.min(target.stats.maxHp, target.currentHp - damage));
        
        results.push({
          effect,
          damage: damage > 0 ? damage : undefined,
          heal: damage < 0 ? -damage : undefined
        });
      }
      
      // æŒç¶šæ™‚é–“æ›´æ–°
      effect.duration--;
      
      // åŠ¹æœåˆ‡ã‚Œãƒã‚§ãƒƒã‚¯
      if (effect.duration <= 0) {
        expiredEffects.push(effect);
      }
    }
    
    // åŠ¹æœåˆ‡ã‚Œã®çŠ¶æ…‹ç•°å¸¸ã‚’å‰Šé™¤
    target.statusEffects = target.statusEffects.filter(e => e.duration > 0);
    
    return {
      processedEffects: results,
      expiredEffects,
      remainingEffects: target.statusEffects
    };
  }
  
  checkActionRestriction(target: Combatant): ActionRestriction {
    // Core Engineã§è¡Œå‹•åˆ¶é™ã‚’ãƒã‚§ãƒƒã‚¯
    return this.coreEngine.checkActionRestriction(target);
  }
}
```



---

## Headless UIå±¤

---

## 13. StatusEffectController - çŠ¶æ…‹ç•°å¸¸è¡¨ç¤ºUIåˆ¶å¾¡

### çŠ¶æ…‹å®šç¾©

```typescript
interface StatusEffectUIState {
  // å¯¾è±¡
  target: Combatant | null;
  
  // çŠ¶æ…‹ç•°å¸¸ä¸€è¦§
  activeEffects: ActiveStatusEffect[];
  
  // è©³ç´°è¡¨ç¤º
  selectedEffect: ActiveStatusEffect | null;
  
  // ãƒ•ã‚£ãƒ«ã‚¿
  filterType: 'all' | 'buff' | 'debuff' | 'ailment' | null;
  
  // ã‚½ãƒ¼ãƒˆ
  sortBy: 'duration' | 'severity' | 'name';
  
  // ã‚«ãƒ¼ã‚½ãƒ«
  cursorIndex: number;
}

interface ActiveStatusEffect {
  id: string;
  effect: StatusEffect;
  target: Combatant;
  source: Combatant | null;
  appliedAt: number;
  duration: number;
  remainingTurns: number;
  stackCount: number;
  category: 'buff' | 'debuff' | 'ailment';
  canDispel: boolean;
}
```

### ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼å®Ÿè£…

```typescript
type StatusEffectEvents = {
  'effect-selected': { effect: ActiveStatusEffect };
  'effect-expired': { effect: ActiveStatusEffect };
  'effect-dispelled': { effect: ActiveStatusEffect };
};

class StatusEffectController {
  private state: ObservableState<StatusEffectUIState>;
  private events: EventEmitter<StatusEffectEvents>;
  private service: StatusEffectService;
  
  constructor(service: StatusEffectService) {
    this.service = service;
    this.state = new ObservableState<StatusEffectUIState>({
      target: null,
      activeEffects: [],
      selectedEffect: null,
      filterType: 'all',
      sortBy: 'duration',
      cursorIndex: 0
    });
    this.events = new EventEmitter<StatusEffectEvents>();
  }
  
  subscribe(listener: (state: StatusEffectUIState) => void): () => void {
    return this.state.subscribe(listener);
  }
  
  on<K extends keyof StatusEffectEvents>(
    event: K,
    listener: (data: StatusEffectEvents[K]) => void
  ): () => void {
    return this.events.on(event, listener);
  }
  
  // çŠ¶æ…‹ç•°å¸¸è¡¨ç¤ºé–‹å§‹
  showStatusEffects(target: Combatant): void {
    const activeEffects = this.getActiveEffects(target);
    
    this.state.setState({
      target,
      activeEffects,
      selectedEffect: null,
      filterType: 'all',
      sortBy: 'duration',
      cursorIndex: 0
    });
  }
  
  // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé¸æŠ
  selectEffect(effect: ActiveStatusEffect): void {
    this.state.setState(prev => ({
      ...prev,
      selectedEffect: effect
    }));
    
    this.events.emit('effect-selected', { effect });
  }
  
  // ãƒ•ã‚£ãƒ«ã‚¿å¤‰æ›´
  setFilter(filterType: 'all' | 'buff' | 'debuff' | 'ailment'): void {
    this.state.setState(prev => ({
      ...prev,
      filterType,
      cursorIndex: 0
    }));
  }
  
  // ã‚½ãƒ¼ãƒˆå¤‰æ›´
  setSortBy(sortBy: 'duration' | 'severity' | 'name'): void {
    this.state.setState(prev => ({
      ...prev,
      sortBy
    }));
  }
  
  // ãƒ•ã‚£ãƒ«ã‚¿ãƒ»ã‚½ãƒ¼ãƒˆæ¸ˆã¿ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå–å¾—
  getFilteredEffects(): ActiveStatusEffect[] {
    const currentState = this.state.getState();
    let effects = currentState.activeEffects;
    
    // ãƒ•ã‚£ãƒ«ã‚¿é©ç”¨
    if (currentState.filterType !== 'all') {
      effects = effects.filter(e => e.category === currentState.filterType);
    }
    
    // ã‚½ãƒ¼ãƒˆé©ç”¨
    effects = [...effects].sort((a, b) => {
      switch (currentState.sortBy) {
        case 'duration':
          return a.remainingTurns - b.remainingTurns;
        case 'name':
          return a.effect.name.localeCompare(b.effect.name);
        case 'severity':
          return (b.effect.severity || 0) - (a.effect.severity || 0);
        default:
          return 0;
      }
    });
    
    return effects;
  }
  
  // è§£é™¤è©¦è¡Œ
  async tryDispel(effect: ActiveStatusEffect): Promise<void> {
    if (!effect.canDispel) {
      return;
    }
    
    const result = this.service.removeStatusEffect(
      effect.target,
      effect.effect.type
    );
    
    if (result.success) {
      // çŠ¶æ…‹ã‚’æ›´æ–°
      this.refreshEffects();
      this.events.emit('effect-dispelled', { effect });
    }
  }
  
  // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ›´æ–°
  refreshEffects(): void {
    const target = this.state.getState().target;
    if (target) {
      const activeEffects = this.getActiveEffects(target);
      this.state.setState(prev => ({
        ...prev,
        activeEffects
      }));
    }
  }
  
  // ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•
  moveCursor(delta: number): void {
    const filteredEffects = this.getFilteredEffects();
    const maxIndex = filteredEffects.length - 1;
    const currentIndex = this.state.getState().cursorIndex;
    const newIndex = Math.max(0, Math.min(maxIndex, currentIndex + delta));
    
    this.state.setState(prev => ({
      ...prev,
      cursorIndex: newIndex
    }));
  }
  
  // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå–å¾—
  private getActiveEffects(target: Combatant): ActiveStatusEffect[] {
    return target.statusEffects.map(effect => ({
      id: `${target.id}-${effect.type}`,
      effect,
      target,
      source: null, // ä»˜ä¸è€…æƒ…å ±ãŒã‚ã‚Œã°è¨­å®š
      appliedAt: Date.now(), // å®Ÿéš›ã®é©ç”¨æ™‚åˆ»
      duration: effect.duration,
      remainingTurns: effect.remainingTurns || 0,
      stackCount: effect.stackCount || 1,
      category: this.categorizeEffect(effect),
      canDispel: effect.canDispel !== false
    }));
  }
  
  private categorizeEffect(effect: StatusEffect): 'buff' | 'debuff' | 'ailment' {
    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç¨®é¡ã«åŸºã¥ã„ã¦åˆ†é¡
    if (effect.type.includes('poison') || effect.type.includes('paralyze')) {
      return 'ailment';
    }
    if (effect.statModifiers) {
      const hasPositive = Object.values(effect.statModifiers).some(v => v > 0);
      return hasPositive ? 'buff' : 'debuff';
    }
    return 'buff';
  }
}
```

---

## UI Frameworkçµ±åˆ

### Reactçµ±åˆ

```typescript
// ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
function useBattleController(service: BattleService) {
  const [state, setState] = useState<BattleUIState>();
  const controllerRef = useRef<BattleController>();
  
  useEffect(() => {
    const controller = new BattleController(service);
    controllerRef.current = controller;
    
    const unsubscribe = controller.subscribe(setState);
    return unsubscribe;
  }, [service]);
  
  return {
    state,
    controller: controllerRef.current,
    startBattle: (party: Character[], enemies: Enemy[]) => 
      controllerRef.current?.startBattle(party, enemies),
    onCommandConfirmed: (action: BattleAction) =>
      controllerRef.current?.onCommandConfirmed(action)
  };
}

// ä½¿ç”¨ä¾‹
function BattleComponent() {
  const { state, startBattle, onCommandConfirmed } = useBattleController(battleService);
  
  // ... ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
}
```

### Vueçµ±åˆ

```typescript
// Composable
export function useBattleController(service: BattleService) {
  const state = ref<BattleUIState>();
  let controller: BattleController;
  
  onMounted(() => {
    controller = new BattleController(service);
    controller.subscribe((newState) => {
      state.value = newState;
    });
  });
  
  const startBattle = (party: Character[], enemies: Enemy[]) => {
    controller.startBattle(party, enemies);
  };
  
  const onCommandConfirmed = (action: BattleAction) => {
    controller.onCommandConfirmed(action);
  };
  
  return {
    state,
    startBattle,
    onCommandConfirmed
  };
}
```

### Svelteçµ±åˆ

```typescript
// Store
import { writable } from 'svelte/store';

export function createBattleStore(service: BattleService) {
  const { subscribe, set } = writable<BattleUIState>();
  
  const controller = new BattleController(service);
  controller.subscribe(set);
  
  return {
    subscribe,
    startBattle: (party: Character[], enemies: Enemy[]) =>
      controller.startBattle(party, enemies),
    onCommandConfirmed: (action: BattleAction) =>
      controller.onCommandConfirmed(action)
  };
}

// ä½¿ç”¨ä¾‹
const battle = createBattleStore(battleService);
```

---

## çŠ¶æ…‹ãƒã‚·ãƒ³

è¤‡é›‘ãªãƒ•ãƒ­ãƒ¼ã¯çŠ¶æ…‹ãƒã‚·ãƒ³ã§ç®¡ç†ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ï¼š

```typescript
type BattlePhase =
  | { type: 'initializing' }
  | { type: 'player-turn'; actor: Character }
  | { type: 'enemy-turn'; enemy: Enemy }
  | { type: 'animating'; animation: BattleAnimation }
  | { type: 'ended'; result: 'victory' | 'defeat' | 'escaped' };

type BattleEvent =
  | { type: 'START_BATTLE'; party: Character[]; enemies: Enemy[] }
  | { type: 'NEXT_TURN' }
  | { type: 'EXECUTE_ACTION'; action: BattleAction }
  | { type: 'ANIMATION_COMPLETE' }
  | { type: 'BATTLE_END'; result: 'victory' | 'defeat' | 'escaped' };

function battleReducer(phase: BattlePhase, event: BattleEvent): BattlePhase {
  switch (phase.type) {
    case 'initializing':
      if (event.type === 'START_BATTLE') {
        // æˆ¦é—˜é–‹å§‹å‡¦ç†
        return { type: 'player-turn', actor: event.party[0] };
      }
      break;
      
    case 'player-turn':
      if (event.type === 'EXECUTE_ACTION') {
        return { type: 'animating', animation: createAnimation(event.action) };
      }
      break;
      
    case 'animating':
      if (event.type === 'ANIMATION_COMPLETE') {
        return { type: 'player-turn', actor: getNextActor() };
      }
      break;
      
    // ... ãã®ä»–ã®é·ç§»
  }
  
  return phase;
}
```

---

## ãƒ†ã‚¹ãƒˆä¾‹

```typescript
describe('BattleController', () => {
  it('should start battle and emit event', async () => {
    const service = new BattleService(coreEngine);
    const controller = new BattleController(service);
    
    let battleStarted = false;
    controller.on('battle-started', () => {
      battleStarted = true;
    });
    
    await controller.startBattle(mockParty, mockEnemies);
    
    expect(battleStarted).toBe(true);
    expect(controller.getState().phase).toBe('selecting-command');
  });
  
  it('should handle command selection', () => {
    const commandController = new CommandController(commandService);
    
    commandController.startCommandSelection(mockCharacter);
    commandController.selectCommand('attack');
    
    expect(commandController.getState().stage).toBe('selecting-target');
  });
});
```

---

## ã¾ã¨ã‚

### ãƒ˜ãƒƒãƒ‰ãƒ¬ã‚¹UIã®åˆ©ç‚¹

1. **å†åˆ©ç”¨æ€§**: åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¤‡æ•°ã®UIãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ä½¿ç”¨å¯èƒ½
2. **ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£**: UIãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãªã—ã§ãƒ­ã‚¸ãƒƒã‚¯ã‚’ãƒ†ã‚¹ãƒˆ
3. **ä¿å®ˆæ€§**: UIã¨ãƒ­ã‚¸ãƒƒã‚¯ã®åˆ†é›¢ã«ã‚ˆã‚Šã€ãã‚Œãã‚Œã‚’ç‹¬ç«‹ã—ã¦å¤‰æ›´å¯èƒ½
4. **æŸ”è»Ÿæ€§**: ãƒ‡ã‚¶ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã‚’è‡ªç”±ã«é¸æŠå¯èƒ½

### å®Ÿè£…å„ªå…ˆåº¦

**ãƒ•ã‚§ãƒ¼ã‚º1: æˆ¦é—˜UI**
1. BattleController - æˆ¦é—˜å…¨ä½“ã®é€²è¡Œç®¡ç†
2. CommandController - ã‚³ãƒãƒ³ãƒ‰é¸æŠUI
3. StatusEffectController - çŠ¶æ…‹ç•°å¸¸è¡¨ç¤ºï¼ˆæˆ¦é—˜ä¸­ã«ä½¿ç”¨ï¼‰

**ãƒ•ã‚§ãƒ¼ã‚º2: ç®¡ç†UI**
4. PartyController - ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆ
5. EquipmentController - è£…å‚™å¤‰æ›´
6. ItemController - ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨

**ãƒ•ã‚§ãƒ¼ã‚º3: æˆé•·ãƒ»å ±é…¬UI**
7. RewardController - æˆ¦é—˜å ±é…¬ã¨ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
8. SkillLearnController - ã‚¹ã‚­ãƒ«ç¿’å¾—
9. JobChangeController - è·æ¥­å¤‰æ›´

**ãƒ•ã‚§ãƒ¼ã‚º4: ç™ºå±•UI**
10. CraftController - ã‚¢ã‚¤ãƒ†ãƒ åˆæˆ
11. EnhanceController - è£…å‚™ãƒ»ã‚­ãƒ£ãƒ©å¼·åŒ–
12. SaveLoadController - ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰

### æ¨å¥¨ãƒ‘ã‚¿ãƒ¼ãƒ³

- **å°è¦æ¨¡ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**: å˜ç´”ãªObservableStateã§ååˆ†
- **ä¸­è¦æ¨¡ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**: çŠ¶æ…‹ãƒã‚·ãƒ³ã‚’è¿½åŠ 
- **å¤§è¦æ¨¡ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**: Redux/Vuex/Zustandãªã©ã®çŠ¶æ…‹ç®¡ç†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨çµ±åˆ

### ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ä¸€è¦§

æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ã€ä»¥ä¸‹ã®13ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®è©³ç´°è¨­è¨ˆã‚’è¨˜è¼‰ã—ã¾ã—ãŸï¼š

| # | Controller | å¯¾å¿œService | æ¦‚è¦ |
|---|-----------|------------|------|
| 1 | BattleController | BattleService | æˆ¦é—˜å…¨ä½“ã®é€²è¡Œã€ã‚¿ãƒ¼ãƒ³ç®¡ç†ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ |
| 2 | CommandController | CommandService | æˆ¦é—˜ä¸­ã®ã‚³ãƒãƒ³ãƒ‰é¸æŠãƒ•ãƒ­ãƒ¼ |
| 3 | ItemController | ItemService | ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨ã®å…¨ãƒ•ãƒ­ãƒ¼ï¼ˆæˆ¦é—˜/ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼‰ |
| 4 | InventoryController | InventoryService | ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªç®¡ç†ã€ãƒ•ã‚£ãƒ«ã‚¿ã€ã‚½ãƒ¼ãƒˆã€ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ |
| 5 | EquipmentController | EquipmentService | è£…å‚™å¤‰æ›´ã€æ¯”è¼ƒã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ |
| 6 | PartyController | PartyService | ãƒ‘ãƒ¼ãƒ†ã‚£ç·¨æˆã€ãƒ¡ãƒ³ãƒãƒ¼å…¥ã‚Œæ›¿ãˆã€éšŠåˆ—å¤‰æ›´ |
| 7 | CraftController | CraftService | ã‚¢ã‚¤ãƒ†ãƒ åˆæˆã€ææ–™ãƒã‚§ãƒƒã‚¯ã€æˆåŠŸç‡è¡¨ç¤º |
| 8 | SkillLearnController | SkillLearnService | ã‚¹ã‚­ãƒ«ç¿’å¾—ã€æ¡ä»¶ãƒã‚§ãƒƒã‚¯ã€ã‚³ã‚¹ãƒˆç®¡ç† |
| 9 | RewardController | RewardService | æˆ¦é—˜å ±é…¬é…åˆ†ã€ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡º |
| 10 | EnhanceController | EnhanceService | è£…å‚™ãƒ»ã‚­ãƒ£ãƒ©å¼·åŒ–ã€æˆåŠŸåˆ¤å®š |
| 11 | SaveLoadController | SaveLoadService | ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰ã€ã‚¹ãƒ­ãƒƒãƒˆç®¡ç† |
| 12 | JobChangeController | JobChangeService | è·æ¥­å¤‰æ›´ã€æ¡ä»¶ãƒã‚§ãƒƒã‚¯ã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰åŒ–ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ |
| 13 | StatusEffectController | StatusEffectService | çŠ¶æ…‹ç•°å¸¸ã®è¡¨ç¤ºã€ãƒ•ã‚£ãƒ«ã‚¿ã€è§£é™¤ |

### UIä¸è¦ã¾ãŸã¯å†…éƒ¨çš„ã«ä½¿ç”¨ã•ã‚Œã‚‹Service

ä»¥ä¸‹ã®Serviceã¯ç‹¬ç«‹ã—ãŸã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’æŒãŸãšã€ä»–ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼å†…ã§ä½¿ç”¨ã•ã‚Œã¾ã™ï¼š

- **EnemyAIService**: BattleControllerå†…ã§æ•µã‚¿ãƒ¼ãƒ³æ™‚ã«è‡ªå‹•çš„ã«ä½¿ç”¨
- **EnemyGroupService**: BattleControlleré–‹å§‹æ™‚ã«æ•µã‚°ãƒ«ãƒ¼ãƒ—ç”Ÿæˆã«ä½¿ç”¨
- **SimulationService**: é«˜åº¦ãªæ©Ÿèƒ½ã¨ã—ã¦ã€å¿…è¦ã«å¿œã˜ã¦å°‚ç”¨UIã‚’å®Ÿè£…

ã“ã®ãƒ˜ãƒƒãƒ‰ãƒ¬ã‚¹UIè¨­è¨ˆã«ã‚ˆã‚Šã€rpg-coreã®Serviceã‚’ä»»æ„ã®UIãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ç°¡å˜ã«åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
