# アイテムシステム設計

アイテムの使用と効果に関する設計。Core Engine、Service、Headless UIの3層で構成。

## 目次

1. [概要](#概要)
2. [Core Engine層](#core-engine層)
3. [Service層](#service層)
4. [Headless UI層](#headless-ui層)

---

## 概要

### 3層アーキテクチャ

```
┌─────────────────────────────────────┐
│  Headless UI Layer                  │
│  Controller                         │  ← UI状態管理、ユーザー操作
└─────────────────────────────────────┘
              ↓ 委譲
┌─────────────────────────────────────┐
│  Service Layer                      │
│  Service                            │  ← ビジネスロジック
└─────────────────────────────────────┘
              ↓ 委譲
┌─────────────────────────────────────┐
│  Core Engine Layer                  │
│  モジュール                          │  ← 純粋な計算
└─────────────────────────────────────┘
```

---

## Core Engine層

このシステムのCore Engine層の実装は他のモジュールを参照してください。

---

## Service層

---

## 3. ItemService - アイテム使用の流れ

### 概要
戦闘中・フィールドでのアイテム使用の流れを管理。使用可否判定、対象選択、効果適用を行う。

### 状態管理

```typescript
interface ItemUseState {
  // 使用段階
  stage: 'selecting-item' | 'selecting-target' | 'confirming' | 'applying';
  
  // コンテキスト
  context: 'battle' | 'field';
  
  // 選択
  selectedItem?: Item;
  selectedTargets?: Character[];
  
  // 結果
  result?: ItemUseResult;
}
```

### 公開インターフェース

```typescript
class ItemService {
  // アイテム使用開始
  startItemUse(context: 'battle' | 'field'): ItemUseState;
  
  // 使用可能なアイテム取得
  getUsableItems(context: 'battle' | 'field'): Item[];
  
  // アイテム選択
  selectItem(item: Item): void;
  
  // 対象選択
  selectTargets(targets: Character[]): void;
  
  // 使用実行
  useItem(): Promise<ItemUseResult>;
  
  // キャンセル
  cancel(): void;
}
```

### Core Engine 委譲

- `item/effects.checkItemUsable()` - 使用可否判定
- `item/effects.calculateItemEffect()` - アイテム効果計算
- `item/effects.getItemTargets()` - 対象取得
- `item/inventory.removeItemFromInventory()` - インベントリから削除

### 実装例

```typescript
class ItemService {
  constructor(private coreEngine: CoreEngine) {}
  
  getUsableItems(context: 'battle' | 'field'): Item[] {
    return this.inventory.items.filter(item => 
      this.coreEngine.checkItemUsable(item, context)
    );
  }
  
  async useItem(): Promise<ItemUseResult> {
    const item = this.state.selectedItem!;
    const targets = this.state.selectedTargets!;
    
    const results: ItemEffectResult[] = [];
    
    // 各ターゲットに効果適用
    for (const target of targets) {
      const effect = this.coreEngine.calculateItemEffect(
        item,
        target,
        this.state.context
      );
      
      // 効果適用
      this.applyItemEffect(target, effect);
      results.push(effect);
    }
    
    // インベントリから削除
    this.coreEngine.removeItemFromInventory(this.inventory, item, 1);
    
    return {
      success: true,
      item,
      targets,
      effects: results
    };
  }
}
```



---

## Headless UI層

---

## 3. ItemController - アイテム使用UI制御

### 状態定義

```typescript
interface ItemUIState {
  // 使用段階
  stage: 'selecting-item' | 'selecting-target' | 'confirming' | 'applying' | 'completed';
  
  // コンテキスト
  context: 'battle' | 'field';
  
  // アイテム一覧
  availableItems: Item[];
  itemCategories: ItemCategory[];
  currentCategory: ItemCategory | null;
  
  // ターゲット候補（コンテキストに応じて設定）
  allTargets: Combatant[]; // 元のターゲットリスト（フィルタリング前）
  availableTargets: Combatant[]; // 現在利用可能なターゲット（フィルタリング後）
  
  // 選択
  selectedItem: Item | null;
  selectedTargets: Combatant[];
  
  // カーソル
  cursorIndex: number;
  
  // 効果プレビュー
  effectPreview: ItemEffectPreview | null;
  
  // 結果
  result: ItemUseResult | null;
  isProcessing: boolean;
}

interface ItemEffectPreview {
  item: Item;
  target: Combatant;
  expectedHeal?: number;
  expectedDamage?: number;
  statusEffects?: StatusEffect[];
}

interface ItemUseResult {
  success: boolean;
  item: Item;
  targets: Combatant[];
  effects: {
    target: Combatant;
    heal?: number;
    damage?: number;
    statusEffectsApplied?: StatusEffect[];
    statusEffectsRemoved?: StatusEffectType[];
  }[];
  message: string;
}
```

### コントローラー実装

```typescript
type ItemEvents = {
  'item-selected': { item: Item };
  'target-selected': { target: Combatant };
  'item-used': { result: ItemUseResult };
  'item-cancelled': {};
};

class ItemController {
  private state: ObservableState<ItemUIState>;
  private events: EventEmitter<ItemEvents>;
  private service: ItemService;
  
  constructor(service: ItemService) {
    this.service = service;
    this.state = new ObservableState<ItemUIState>({
      stage: 'selecting-item',
      context: 'field',
      availableItems: [],
      itemCategories: [],
      currentCategory: null,
      allTargets: [],
      availableTargets: [],
      selectedItem: null,
      selectedTargets: [],
      cursorIndex: 0,
      effectPreview: null,
      result: null,
      isProcessing: false
    });
    this.events = new EventEmitter<ItemEvents>();
  }
  
  subscribe(listener: (state: ItemUIState) => void): () => void {
    return this.state.subscribe(listener);
  }
  
  on<K extends keyof ItemEvents>(
    event: K,
    listener: (data: ItemEvents[K]) => void
  ): () => void {
    return this.events.on(event, listener);
  }
  
  // アイテム使用開始（フィールド用）
  startItemUse(context: 'field', party: Character[]): void;
  // アイテム使用開始（戦闘用）
  startItemUse(context: 'battle', party: Character[], enemies: Enemy[]): void;
  startItemUse(context: 'battle' | 'field', party: Character[], enemies?: Enemy[]): void {
    this.service.startItemUse(context);
    
    const availableItems = this.service.getUsableItems(context);
    const categories = this.categorizeItems(availableItems);
    
    // コンテキストに応じてターゲット候補を設定
    // フィールドではパーティメンバーのみ、戦闘では味方と敵の両方
    const allTargets: Combatant[] = context === 'battle' && enemies
      ? [...party, ...enemies]
      : party;
    
    this.state.setState({
      stage: 'selecting-item',
      context,
      availableItems,
      itemCategories: categories,
      currentCategory: categories[0] || null,
      allTargets, // 元のリストを保持
      availableTargets: allTargets, // 初期状態では全ターゲット
      selectedItem: null,
      selectedTargets: [],
      cursorIndex: 0,
      effectPreview: null,
      result: null,
      isProcessing: false
    });
  }
  
  // カテゴリー変更
  selectCategory(category: ItemCategory): void {
    const filteredItems = this.state.getState().availableItems.filter(
      item => item.category === category
    );
    
    this.state.setState(prev => ({
      ...prev,
      currentCategory: category,
      cursorIndex: 0
    }));
  }
  
  // アイテム選択
  selectItem(item: Item): void {
    this.service.selectItem(item);
    
    this.state.setState(prev => ({
      ...prev,
      selectedItem: item
    }));
    
    this.events.emit('item-selected', { item });
    
    // ターゲット選択が必要か判定
    if (this.requiresTargetSelection(item)) {
      this.moveToTargetSelection(item);
    } else {
      // ターゲット不要（全体効果など）
      this.confirm();
    }
  }
  
  // ターゲット選択へ移動
  private moveToTargetSelection(item: Item): void {
    // allTargetsから元のターゲットリストを取得
    const allTargets = this.state.getState().allTargets;
    const filteredTargets = this.filterTargetsByItemType(item, allTargets);
    
    this.state.setState(prev => ({
      ...prev,
      stage: 'selecting-target',
      availableTargets: filteredTargets, // フィルタリング後のリストのみ更新
      cursorIndex: 0
    }));
  }
  
  // アイテムタイプに応じたターゲットフィルタリング
  private filterTargetsByItemType(item: Item, allTargets: Combatant[]): Combatant[] {
    const context = this.state.getState().context;
    
    if (context === 'field') {
      // フィールドでは常に味方のみ
      return allTargets.filter(t => 'job' in t); // Character判定
    }
    
    // 戦闘中
    switch (item.targetType) {
      case 'ally':
      case 'single-ally':
        // 味方のみ（Character）
        return allTargets.filter(t => 'job' in t && t.currentHp > 0);
        
      case 'enemy':
      case 'single-enemy':
        // 敵のみ（Enemy）
        return allTargets.filter(t => !('job' in t) && t.currentHp > 0);
        
      case 'single':
      case 'any':
        // 味方・敵どちらでも可
        return allTargets.filter(t => t.currentHp > 0);
        
      case 'all-allies':
        // 全味方
        return allTargets.filter(t => 'job' in t);
        
      case 'all-enemies':
        // 全敵
        return allTargets.filter(t => !('job' in t));
        
      case 'all':
        // 全員
        return allTargets;
        
      default:
        return allTargets;
    }
  }
  
  // ターゲット選択
  selectTarget(target: Combatant): void {
    const item = this.state.getState().selectedItem!;
    
    this.service.selectTargets([target]);
    
    // 効果プレビュー更新
    const preview = this.createEffectPreview(item, target);
    
    this.state.setState(prev => ({
      ...prev,
      selectedTargets: [target],
      effectPreview: preview
    }));
    
    this.events.emit('target-selected', { target });
  }
  
  // 効果プレビュー作成
  private createEffectPreview(item: Item, target: Combatant): ItemEffectPreview {
    // Serviceを通じて効果を計算
    const expectedHeal = item.healAmount ? item.healAmount : undefined;
    const expectedDamage = item.damageAmount ? item.damageAmount : undefined;
    const statusEffects = item.statusEffects || [];
    
    return {
      item,
      target,
      expectedHeal,
      expectedDamage,
      statusEffects
    };
  }
  
  // カーソル移動
  moveCursor(delta: number): void {
    const currentState = this.state.getState();
    let maxIndex = 0;
    
    if (currentState.stage === 'selecting-item') {
      const filteredItems = currentState.currentCategory
        ? currentState.availableItems.filter(i => i.category === currentState.currentCategory)
        : currentState.availableItems;
      maxIndex = filteredItems.length - 1;
    } else if (currentState.stage === 'selecting-target') {
      // 利用可能なターゲット数
      maxIndex = currentState.availableTargets.length - 1;
    }
    
    const newIndex = Math.max(0, Math.min(maxIndex, currentState.cursorIndex + delta));
    
    this.state.setState(prev => ({
      ...prev,
      cursorIndex: newIndex
    }));
  }
  
  // 確認・使用実行
  async confirm(): Promise<void> {
    this.state.setState(prev => ({
      ...prev,
      stage: 'applying',
      isProcessing: true
    }));
    
    try {
      const result = await this.service.useItem();
      
      this.state.setState(prev => ({
        ...prev,
        stage: 'completed',
        result: result as ItemUseResult,
        isProcessing: false
      }));
      
      this.events.emit('item-used', { result: result as ItemUseResult });
    } catch (error) {
      // エラー処理
      this.state.setState(prev => ({
        ...prev,
        stage: 'selecting-item',
        isProcessing: false
      }));
    }
  }
  
  // キャンセル
  cancel(): void {
    this.service.cancel();
    
    const currentState = this.state.getState();
    
    if (currentState.stage === 'selecting-target') {
      // アイテム選択に戻る
      // allTargetsを保持しているので、availableTargetsをリセット
      this.state.setState(prev => ({
        ...prev,
        stage: 'selecting-item',
        selectedItem: null,
        selectedTargets: [],
        availableTargets: prev.allTargets, // 元のリストに戻す
        effectPreview: null,
        cursorIndex: 0
      }));
    } else {
      // 完全にキャンセル
      this.events.emit('item-cancelled', {});
    }
  }
  
  // ユーティリティ
  private requiresTargetSelection(item: Item): boolean {
    // 全体効果以外はターゲット選択が必要
    return item.targetType !== 'all' && 
           item.targetType !== 'all-allies' && 
           item.targetType !== 'all-enemies';
  }
  
  private categorizeItems(items: Item[]): ItemCategory[] {
    const categories = new Set(items.map(item => item.category));
    return Array.from(categories);
  }
}
```

### 使用例（React）

```typescript
// フィールドでの使用例
function ItemMenuField() {
  const [state, setState] = useState<ItemUIState>();
  const controllerRef = useRef<ItemController>();
  
  useEffect(() => {
    const service = new ItemService(coreEngine);
    const controller = new ItemController(service);
    controllerRef.current = controller;
    
    const unsubscribe = controller.subscribe(setState);
    
    // フィールドではパーティのみ渡す
    controller.startItemUse('field', party);
    
    return unsubscribe;
  }, []);
  
  if (!state) return <div>Loading...</div>;
  
  return (
    <div className="item-menu">
      {state.stage === 'selecting-item' && (
        <ItemList
          items={state.availableItems}
          categories={state.itemCategories}
          currentCategory={state.currentCategory}
          cursorIndex={state.cursorIndex}
          onSelectItem={(item) => controllerRef.current?.selectItem(item)}
          onSelectCategory={(cat) => controllerRef.current?.selectCategory(cat)}
        />
      )}
      
      {state.stage === 'selecting-target' && (
        <TargetSelection
          targets={state.availableTargets}
          selectedTargets={state.selectedTargets}
          preview={state.effectPreview}
          onSelectTarget={(target) => controllerRef.current?.selectTarget(target)}
        />
      )}
      
      {state.stage === 'completed' && state.result && (
        <ItemUseResult result={state.result} />
      )}
    </div>
  );
}

// 戦闘中での使用例
function ItemMenuBattle({ party, enemies }: { party: Character[]; enemies: Enemy[] }) {
  const [state, setState] = useState<ItemUIState>();
  const controllerRef = useRef<ItemController>();
  
  useEffect(() => {
    const service = new ItemService(coreEngine);
    const controller = new ItemController(service);
    controllerRef.current = controller;
    
    const unsubscribe = controller.subscribe(setState);
    
    // 戦闘中はパーティと敵を両方渡す
    controller.startItemUse('battle', party, enemies);
    
    return unsubscribe;
  }, [party, enemies]);
  
  if (!state) return <div>Loading...</div>;
  
  return (
    <div className="item-menu-battle">
      {state.stage === 'selecting-item' && (
        <ItemList
          items={state.availableItems}
          categories={state.itemCategories}
          currentCategory={state.currentCategory}
          cursorIndex={state.cursorIndex}
          onSelectItem={(item) => controllerRef.current?.selectItem(item)}
          onSelectCategory={(cat) => controllerRef.current?.selectCategory(cat)}
        />
      )}
      
      {state.stage === 'selecting-target' && (
        <BattleTargetSelection
          allies={party}
          enemies={enemies}
          availableTargets={state.availableTargets}
          selectedTargets={state.selectedTargets}
          preview={state.effectPreview}
          onSelectTarget={(target) => controllerRef.current?.selectTarget(target)}
        />
      )}
      
      {state.stage === 'completed' && state.result && (
        <ItemUseResult result={state.result} />
      )}
    </div>
  );
}
```


