# æˆ¦é—˜ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ

æˆ¦é—˜ã«é–¢ã™ã‚‹åŒ…æ‹¬çš„ãªè¨­è¨ˆã€‚Core Engineã€Serviceã€Headless UIã®3å±¤ã§æ§‹æˆã€‚

## ç›®æ¬¡

1. [æ¦‚è¦](#æ¦‚è¦)
2. [Core Engineå±¤](#core-engineå±¤)
3. [Serviceå±¤](#serviceå±¤)
4. [Headless UIå±¤](#headless-uiå±¤)

---

## æ¦‚è¦

### ã‚·ã‚¹ãƒ†ãƒ ã®å½¹å‰²

æˆ¦é—˜ã‚·ã‚¹ãƒ†ãƒ ã¯ä»¥ä¸‹ã®æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ï¼š

- **ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—**: ç‰©ç†æ”»æ’ƒã€é­”æ³•æ”»æ’ƒã€å›å¾©ãªã©ã®è¨ˆç®—
- **è¡Œå‹•é †ç®¡ç†**: ç´ æ—©ã•ã«åŸºã¥ãè¡Œå‹•é †ã®æ±ºå®š
- **ã‚³ãƒãƒ³ãƒ‰é¸æŠ**: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æˆ¦é—˜ã‚³ãƒãƒ³ãƒ‰é¸æŠãƒ•ãƒ­ãƒ¼
- **å‹æ•—åˆ¤å®š**: æˆ¦é—˜ã®å‹åˆ©ãƒ»æ•—åŒ—ãƒ»é€ƒèµ°ã®åˆ¤å®š

### 3å±¤ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Headless UI Layer                  â”‚
â”‚  BattleController                   â”‚  â† UIçŠ¶æ…‹ç®¡ç†ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œ
â”‚  CommandController                  â”‚
â”‚  - è¡¨ç¤ºçŠ¶æ…‹ã®ç®¡ç†                    â”‚
â”‚  - ã‚³ãƒãƒ³ãƒ‰é¸æŠã®ç®¡ç†                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ å§”è­²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Service Layer                      â”‚
â”‚  BattleService                      â”‚  â† ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯
â”‚  CommandService                     â”‚
â”‚  - æˆ¦é—˜ãƒ•ãƒ­ãƒ¼ã®ç®¡ç†                  â”‚
â”‚  - ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã®èª¿æ•´                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ å§”è­²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Core Engine Layer                  â”‚
â”‚  combat/ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«                 â”‚  â† ç´”ç²‹ãªè¨ˆç®—
â”‚  - ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—                      â”‚
â”‚  - å‘½ä¸­åˆ¤å®š                          â”‚
â”‚  - è¡Œå‹•é †è¨ˆç®—                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Core Engineå±¤

### ğŸ® æˆ¦é—˜ã«é–¢ã™ã‚‹è¨ˆç®—

#### è¡Œå‹•é †ã®è¨ˆç®—
- ç´ æ—©ã•ã«åŸºã¥ãè¡Œå‹•é †ã®æ±ºå®š
- å…ˆåˆ¶æ”»æ’ƒãƒ»ä¸æ„æ‰“ã¡ã®åˆ¤å®š
- è¡Œå‹•é †è£œæ­£ã®é©ç”¨

#### ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
- ç‰©ç†æ”»æ’ƒã®ãƒ€ãƒ¡ãƒ¼ã‚¸
  - æ”»æ’ƒåŠ› - é˜²å¾¡åŠ›ã‚’åŸºæº–ã¨ã—ãŸè¨ˆç®—
  - æ­¦å™¨ã®æ”»æ’ƒåŠ›è£œæ­£
  - ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ’ãƒƒãƒˆåˆ¤å®šã¨å€ç‡
  - å±æ€§ç›¸æ€§ã«ã‚ˆã‚‹è£œæ­£
  - ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã®ä»˜ä¸
- é­”æ³•æ”»æ’ƒã®ãƒ€ãƒ¡ãƒ¼ã‚¸
  - é­”åŠ›ãƒ™ãƒ¼ã‚¹ã®è¨ˆç®—
  - é­”æ³•é˜²å¾¡ã«ã‚ˆã‚‹è»½æ¸›
  - å±æ€§ç›¸æ€§ã«ã‚ˆã‚‹è£œæ­£
- ã‚¹ã‚­ãƒ«ã®ãƒ€ãƒ¡ãƒ¼ã‚¸
  - ã‚¹ã‚­ãƒ«å›ºæœ‰ã®å€ç‡
  - ã‚³ã‚¹ãƒˆï¼ˆMPã€SPãªã©ï¼‰ã®è¨ˆç®—

#### å›å¾©é‡ã®è¨ˆç®—
- å›å¾©ã‚¹ã‚­ãƒ«ã®åŠ¹æœé‡
  - å›ºå®šå€¤å›å¾©
  - å‰²åˆå›å¾©
  - æœ€å¤§HPã«åŸºã¥ãå›å¾©
- ã‚¢ã‚¤ãƒ†ãƒ ã«ã‚ˆã‚‹å›å¾©
- ç¶™ç¶šå›å¾©ã®è¨ˆç®—

#### å‘½ä¸­ãƒ»å›é¿ã®åˆ¤å®š
- å‘½ä¸­ç‡ã®è¨ˆç®—
- å›é¿ç‡ã®è¨ˆç®—
- å¿…ä¸­ã‚¹ã‚­ãƒ«ã®å‡¦ç†

#### å‹åˆ©æ¡ä»¶ãƒ»æ•—åŒ—æ¡ä»¶ã®åˆ¤å®š
- å…¨æ»…åˆ¤å®š
- é€ƒèµ°æˆåŠŸç‡ã®è¨ˆç®—
- ç‰¹æ®Šå‹åˆ©æ¡ä»¶ã®åˆ¤å®š



---

## Serviceå±¤

## 1. BattleService - æˆ¦é—˜å…¨ä½“ã®é€²è¡Œç®¡ç†

### æ¦‚è¦
æˆ¦é—˜é–‹å§‹ã‹ã‚‰çµ‚äº†ã¾ã§ã®å…¨ä½“ãƒ•ãƒ­ãƒ¼ã‚’ç®¡ç†ã—ã€ã‚¿ãƒ¼ãƒ³é€²è¡Œã€ãƒ•ã‚§ãƒ¼ã‚ºåˆ‡ã‚Šæ›¿ãˆã€å‹æ•—åˆ¤å®šã‚’è¡Œã†ã€‚

### çŠ¶æ…‹ç®¡ç†

```typescript
interface BattleState {
  // æˆ¦é—˜çŠ¶æ…‹
  phase: 'initializing' | 'player-turn' | 'enemy-turn' | 'processing' | 'ended';
  turnNumber: number;
  
  // å‚åŠ è€…
  playerParty: Character[];
  enemyGroup: Enemy[];
  
  // è¡Œå‹•é †
  turnOrder: Combatant[];
  currentActorIndex: number;
  
  // æˆ¦é—˜çµæœ
  result?: 'victory' | 'defeat' | 'escaped';
  rewards?: BattleRewards;
  
  // å±¥æ­´
  actionHistory: BattleAction[];
}
```

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class BattleService {
  // æˆ¦é—˜é–‹å§‹
  startBattle(party: Character[], enemies: Enemy[]): Promise<void>;
  
  // ã‚¿ãƒ¼ãƒ³é€²è¡Œ
  advanceTurn(): Promise<void>;
  
  // è¡Œå‹•å®Ÿè¡Œ
  executeAction(actor: Combatant, action: BattleAction): Promise<ActionResult>;
  
  // é€ƒèµ°è©¦è¡Œ
  attemptEscape(): Promise<EscapeResult>;
  
  // æˆ¦é—˜çµ‚äº†ãƒã‚§ãƒƒã‚¯
  checkBattleEnd(): BattleEndCheck;
  
  // ç¾åœ¨ã®çŠ¶æ…‹å–å¾—
  getState(): BattleState;
  
  // æˆ¦é—˜çµ‚äº†
  endBattle(): BattleRewards;
}
```

### Core Engine å§”è­²

- `combat/turnOrder.calculateTurnOrder()` - è¡Œå‹•é †è¨ˆç®—
- `combat/turnOrder.checkPreemptiveStrike()` - å…ˆåˆ¶æ”»æ’ƒåˆ¤å®š
- `combat/damage.calculatePhysicalDamage()` - ç‰©ç†ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
- `combat/damage.calculateMagicDamage()` - é­”æ³•ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
- `combat/accuracy.checkHit()` - å‘½ä¸­åˆ¤å®š
- `combat/accuracy.checkCritical()` - ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«åˆ¤å®š
- `combat/victory.checkVictoryCondition()` - å‹åˆ©æ¡ä»¶åˆ¤å®š
- `combat/victory.checkDefeatCondition()` - æ•—åŒ—æ¡ä»¶åˆ¤å®š
- `combat/victory.calculateEscapeRate()` - é€ƒèµ°æˆåŠŸç‡è¨ˆç®—
- `status/duration.updateEffectDuration()` - çŠ¶æ…‹ç•°å¸¸ã®æŒç¶šæ™‚é–“æ›´æ–°

### ãƒ•ãƒ­ãƒ¼

```
1. startBattle() â†’ åˆæœŸåŒ–
   â†“
2. calculateTurnOrder() â†’ è¡Œå‹•é †æ±ºå®š
   â†“
3. [ãƒ«ãƒ¼ãƒ—é–‹å§‹]
   â†“
4. advanceTurn() â†’ æ¬¡ã®è¡Œå‹•è€…ã‚’å–å¾—
   â†“
5. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³ï¼Ÿ
   â”œâ”€Yesâ†’ CommandServiceã§å…¥åŠ›å¾…ã¡
   â””â”€No â†’ EnemyAIServiceã§è¡Œå‹•æ±ºå®š
   â†“
6. executeAction() â†’ è¡Œå‹•å®Ÿè¡Œ
   â†“
7. checkBattleEnd() â†’ å‹æ•—åˆ¤å®š
   â”œâ”€ç¶™ç¶š â†’ 3ã«æˆ»ã‚‹
   â””â”€çµ‚äº† â†’ 8ã¸
   â†“
8. endBattle() â†’ å ±é…¬è¨ˆç®—ãƒ»æˆ¦é—˜çµ‚äº†
```

### å®Ÿè£…ä¾‹

```typescript
class BattleService {
  constructor(
    private coreEngine: CoreEngine,
    private commandService: CommandService,
    private enemyAIService: EnemyAIService
  ) {}
  
  async startBattle(party: Character[], enemies: Enemy[]): Promise<void> {
    // æˆ¦é—˜åˆæœŸåŒ–
    this.state = {
      phase: 'initializing',
      turnNumber: 0,
      playerParty: [...party],
      enemyGroup: [...enemies],
      turnOrder: [],
      currentActorIndex: 0,
      actionHistory: []
    };
    
    // å…ˆåˆ¶æ”»æ’ƒãƒã‚§ãƒƒã‚¯
    const preemptive = this.coreEngine.checkPreemptiveStrike(party, enemies);
    
    // è¡Œå‹•é †è¨ˆç®—
    const allCombatants = [...party, ...enemies];
    this.state.turnOrder = this.coreEngine.calculateTurnOrder(allCombatants);
    
    this.state.phase = 'player-turn';
  }
  
  async advanceTurn(): Promise<void> {
    // æ¬¡ã®è¡Œå‹•è€…ã‚’å–å¾—
    const actor = this.state.turnOrder[this.state.currentActorIndex];
    
    if (!actor || actor.currentHp <= 0) {
      // ã‚¹ã‚­ãƒƒãƒ—
      this.currentActorIndex++;
      return this.advanceTurn();
    }
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹æ•µã‹ã§åˆ†å²
    if (this.isPlayerCharacter(actor)) {
      this.state.phase = 'player-turn';
      // UIã§å…¥åŠ›ã‚’å¾…ã¤
    } else {
      this.state.phase = 'enemy-turn';
      // AIã§è¡Œå‹•æ±ºå®š
      const action = await this.enemyAIService.decideAction(actor as Enemy, this.state);
      await this.executeAction(actor, action);
    }
  }
  
  checkBattleEnd(): BattleEndCheck {
    // å‹åˆ©æ¡ä»¶ãƒã‚§ãƒƒã‚¯
    if (this.coreEngine.checkVictoryCondition(this.state.enemyGroup)) {
      return { isEnded: true, result: 'victory' };
    }
    
    // æ•—åŒ—æ¡ä»¶ãƒã‚§ãƒƒã‚¯
    if (this.coreEngine.checkDefeatCondition(this.state.playerParty)) {
      return { isEnded: true, result: 'defeat' };
    }
    
    return { isEnded: false };
  }
}
```



---

## 2. CommandService - æˆ¦é—˜ä¸­ã®ã‚³ãƒãƒ³ãƒ‰é¸æŠ

### æ¦‚è¦
æˆ¦é—˜ä¸­ã®ã‚³ãƒãƒ³ãƒ‰ï¼ˆæ”»æ’ƒãƒ»ã‚¹ã‚­ãƒ«ãƒ»ã‚¢ã‚¤ãƒ†ãƒ ãƒ»é˜²å¾¡ãƒ»é€ƒèµ°ï¼‰ã®é¸æŠè‚¢æç¤ºã¨æ±ºå®šå‡¦ç†ã‚’ç®¡ç†ã€‚

### çŠ¶æ…‹ç®¡ç†

```typescript
interface CommandState {
  // ç¾åœ¨ã®ã‚³ãƒãƒ³ãƒ‰é¸æŠæ®µéš
  stage: 'selecting-action' | 'selecting-skill' | 'selecting-item' | 'selecting-target';
  
  // è¡Œå‹•ä¸­ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
  actor: Character;
  
  // é¸æŠä¸­ã®ã‚³ãƒãƒ³ãƒ‰
  selectedCommand?: 'attack' | 'skill' | 'item' | 'defend' | 'escape';
  selectedSkill?: Skill;
  selectedItem?: Item;
  selectedTargets?: Combatant[];
  
  // åˆ©ç”¨å¯èƒ½ãªé¸æŠè‚¢
  availableCommands: CommandOption[];
  availableSkills: Skill[];
  availableItems: Item[];
  availableTargets: Combatant[];
}
```

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class CommandService {
  // ã‚³ãƒãƒ³ãƒ‰é¸æŠé–‹å§‹
  startCommandSelection(actor: Character, battleState: BattleState): CommandState;
  
  // åˆ©ç”¨å¯èƒ½ãªã‚³ãƒãƒ³ãƒ‰ã‚’å–å¾—
  getAvailableCommands(actor: Character): CommandOption[];
  
  // ã‚³ãƒãƒ³ãƒ‰é¸æŠ
  selectCommand(command: string): void;
  
  // ã‚¹ã‚­ãƒ«/ã‚¢ã‚¤ãƒ†ãƒ é¸æŠ
  selectSkill(skill: Skill): void;
  selectItem(item: Item): void;
  
  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
  selectTarget(target: Combatant): void;
  selectTargets(targets: Combatant[]): void;
  
  // æ±ºå®š
  confirm(): BattleAction;
  
  // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  cancel(): void;
}
```

### Core Engine å§”è­²

- `character/skill.checkSkillUsable()` - ã‚¹ã‚­ãƒ«ä½¿ç”¨å¯å¦åˆ¤å®š
- `character/skill.calculateSkillCost()` - ã‚¹ã‚­ãƒ«ã‚³ã‚¹ãƒˆè¨ˆç®—
- `item/effects.checkItemUsable()` - ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨å¯å¦åˆ¤å®š
- `item/effects.getItemTargets()` - ã‚¢ã‚¤ãƒ†ãƒ å¯¾è±¡å–å¾—

### ãƒ•ãƒ­ãƒ¼

```
1. startCommandSelection() â†’ é¸æŠé–‹å§‹
   â†“
2. getAvailableCommands() â†’ ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§è¡¨ç¤º
   â†“
3. selectCommand() â†’ ã‚³ãƒãƒ³ãƒ‰é¸æŠ
   â†“
4. ã‚³ãƒãƒ³ãƒ‰ã«å¿œã˜ã¦åˆ†å²:
   - æ”»æ’ƒ â†’ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠã¸
   - ã‚¹ã‚­ãƒ« â†’ ã‚¹ã‚­ãƒ«ä¸€è¦§è¡¨ç¤º
   - ã‚¢ã‚¤ãƒ†ãƒ  â†’ ã‚¢ã‚¤ãƒ†ãƒ ä¸€è¦§è¡¨ç¤º
   - é˜²å¾¡ â†’ å³ç¢ºå®š
   - é€ƒèµ° â†’ å³å®Ÿè¡Œ
   â†“
5. selectSkill/selectItem() â†’ è©³ç´°é¸æŠ
   â†“
6. selectTarget() â†’ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
   â†“
7. confirm() â†’ è¡Œå‹•ç¢ºå®šã€BattleActionã‚’è¿”ã™
```

### å®Ÿè£…ä¾‹

```typescript
class CommandService {
  constructor(private coreEngine: CoreEngine) {}
  
  getAvailableCommands(actor: Character): CommandOption[] {
    const commands: CommandOption[] = [];
    
    // æ”»æ’ƒã¯å¸¸ã«å¯èƒ½
    commands.push({ type: 'attack', label: 'æ”»æ’ƒ', enabled: true });
    
    // ã‚¹ã‚­ãƒ«ãƒã‚§ãƒƒã‚¯
    const usableSkills = actor.skills.filter(skill => 
      this.coreEngine.checkSkillUsable(actor, skill)
    );
    if (usableSkills.length > 0) {
      commands.push({ type: 'skill', label: 'ã‚¹ã‚­ãƒ«', enabled: true });
    }
    
    // ã‚¢ã‚¤ãƒ†ãƒ ãƒã‚§ãƒƒã‚¯
    const usableItems = this.getUsableItemsInBattle(actor);
    if (usableItems.length > 0) {
      commands.push({ type: 'item', label: 'ã‚¢ã‚¤ãƒ†ãƒ ', enabled: true });
    }
    
    // é˜²å¾¡ã¯å¸¸ã«å¯èƒ½
    commands.push({ type: 'defend', label: 'é˜²å¾¡', enabled: true });
    
    // é€ƒèµ°ã¯å¸¸ã«è©¦è¡Œå¯èƒ½
    commands.push({ type: 'escape', label: 'é€ƒã’ã‚‹', enabled: true });
    
    return commands;
  }
  
  selectCommand(command: string): void {
    this.state.selectedCommand = command as any;
    
    switch (command) {
      case 'attack':
        this.state.stage = 'selecting-target';
        this.state.availableTargets = this.getAttackTargets();
        break;
        
      case 'skill':
        this.state.stage = 'selecting-skill';
        this.state.availableSkills = this.getUsableSkills(this.state.actor);
        break;
        
      case 'item':
        this.state.stage = 'selecting-item';
        this.state.availableItems = this.getUsableItemsInBattle(this.state.actor);
        break;
        
      case 'defend':
      case 'escape':
        // ã™ãã«ç¢ºå®š
        break;
    }
  }
  
  confirm(): BattleAction {
    return {
      actor: this.state.actor,
      type: this.state.selectedCommand!,
      skill: this.state.selectedSkill,
      item: this.state.selectedItem,
      targets: this.state.selectedTargets || []
    };
  }
}
```



---

## Headless UIå±¤

## 1. BattleController - æˆ¦é—˜UIåˆ¶å¾¡

### çŠ¶æ…‹å®šç¾©

```typescript
interface BattleUIState {
  // æˆ¦é—˜çŠ¶æ…‹
  phase: 'initializing' | 'selecting-command' | 'executing-action' | 'animating' | 'ended';
  turnNumber: number;
  
  // å‚åŠ è€…
  playerParty: Character[];
  enemyGroup: Enemy[];
  
  // ç¾åœ¨ã®ã‚¢ã‚¯ã‚¿ãƒ¼
  currentActor: Combatant | null;
  
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  currentAnimation: BattleAnimation | null;
  animationQueue: BattleAnimation[];
  
  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
  messages: BattleMessage[];
  
  // çµæœ
  result: 'victory' | 'defeat' | 'escaped' | null;
  rewards: BattleRewards | null;
  
  // UIåˆ¶å¾¡
  isWaitingForInput: boolean;
  canSkipAnimation: boolean;
}

interface BattleAnimation {
  type: 'damage' | 'heal' | 'skill' | 'status-effect' | 'ko';
  actor: Combatant;
  targets: Combatant[];
  value?: number;
  skillName?: string;
  duration: number;
}

type BattleMessageType = 
  | 'battle-start'
  | 'action-execute'
  | 'damage'
  | 'heal'
  | 'battle-end'
  | 'turn-start';

interface BattleMessageData {
  actorName?: string;
  actionName?: string;
  damage?: number;
  heal?: number;
  result?: 'victory' | 'defeat' | 'escaped';
  turnNumber?: number;
  [key: string]: any; // æ‹¡å¼µå¯èƒ½
}

interface BattleMessage {
  id: string;
  type: BattleMessageType;
  data: BattleMessageData;
  timestamp: number;
}
```

### ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼å®Ÿè£…

```typescript
type BattleEvents = {
  'battle-started': { party: Character[]; enemies: Enemy[] };
  'turn-started': { turnNumber: number; actor: Combatant };
  'action-executed': { action: BattleAction; result: ActionResult };
  'battle-ended': { result: 'victory' | 'defeat' | 'escaped'; rewards?: BattleRewards };
  'animation-started': BattleAnimation;
  'animation-completed': BattleAnimation;
  'message-added': BattleMessage;
};

class BattleController {
  private state: ObservableState<BattleUIState>;
  private events: EventEmitter<BattleEvents>;
  private service: BattleService;
  private commandController: CommandController;
  
  constructor(service: BattleService) {
    this.service = service;
    this.state = new ObservableState<BattleUIState>({
      phase: 'initializing',
      turnNumber: 0,
      playerParty: [],
      enemyGroup: [],
      currentActor: null,
      currentAnimation: null,
      animationQueue: [],
      messages: [],
      result: null,
      rewards: null,
      isWaitingForInput: false,
      canSkipAnimation: true
    });
    this.events = new EventEmitter<BattleEvents>();
    this.commandController = new CommandController(service.commandService);
  }
  
  // çŠ¶æ…‹ã®è³¼èª­
  subscribe(listener: (state: BattleUIState) => void): () => void {
    return this.state.subscribe(listener);
  }
  
  // ã‚¤ãƒ™ãƒ³ãƒˆã®è³¼èª­
  on<K extends keyof BattleEvents>(
    event: K,
    listener: (data: BattleEvents[K]) => void
  ): () => void {
    return this.events.on(event, listener);
  }
  
  // æˆ¦é—˜é–‹å§‹
  async startBattle(party: Character[], enemies: Enemy[]): Promise<void> {
    await this.service.startBattle(party, enemies);
    
    this.state.setState({
      ...this.state.getState(),
      phase: 'selecting-command',
      playerParty: [...party],
      enemyGroup: [...enemies],
      turnNumber: 1
    });
    
    this.events.emit('battle-started', { party, enemies });
    this.addMessage('battle-start', {});
    
    await this.advanceTurn();
  }
  
  // ã‚¿ãƒ¼ãƒ³é€²è¡Œ
  private async advanceTurn(): Promise<void> {
    const turnOrder = this.service.getState().turnOrder;
    const currentIndex = this.service.getState().currentActorIndex;
    const actor = turnOrder[currentIndex];
    
    if (!actor) {
      // æˆ¦é—˜çµ‚äº†ãƒã‚§ãƒƒã‚¯
      const endCheck = this.service.checkBattleEnd();
      if (endCheck.isEnded) {
        await this.endBattle(endCheck.result!);
        return;
      }
      
      // æ–°ã—ã„ã‚¿ãƒ¼ãƒ³é–‹å§‹
      this.state.setState(prev => ({
        ...prev,
        turnNumber: prev.turnNumber + 1
      }));
      await this.service.advanceTurn();
      return this.advanceTurn();
    }
    
    this.state.setState(prev => ({
      ...prev,
      currentActor: actor
    }));
    
    this.events.emit('turn-started', { turnNumber: this.state.getState().turnNumber, actor });
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹æ•µã‹ã§åˆ†å²
    if (this.isPlayerCharacter(actor)) {
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³ - ã‚³ãƒãƒ³ãƒ‰é¸æŠå¾…ã¡
      this.state.setState(prev => ({
        ...prev,
        phase: 'selecting-command',
        isWaitingForInput: true
      }));
      
      this.commandController.startCommandSelection(actor as Character);
    } else {
      // æ•µã‚¿ãƒ¼ãƒ³ - AIè¡Œå‹•
      this.state.setState(prev => ({
        ...prev,
        phase: 'executing-action',
        isWaitingForInput: false
      }));
      
      const action = await this.service.enemyAIService.decideAction(
        actor as Enemy,
        this.service.getState()
      );
      
      await this.executeAction(action);
    }
  }
  
  // è¡Œå‹•å®Ÿè¡Œ
  async executeAction(action: BattleAction): Promise<void> {
    this.state.setState(prev => ({
      ...prev,
      phase: 'executing-action',
      isWaitingForInput: false
    }));
    
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    this.addMessage('action-execute', {
      actorName: action.actor.name,
      actionName: this.getActionName(action)
    });
    
    // ServiceçµŒç”±ã§å®Ÿè¡Œ
    const result = await this.service.executeAction(action.actor, action);
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¿½åŠ 
    this.queueAnimation({
      type: this.getAnimationType(action),
      actor: action.actor,
      targets: action.targets,
      value: result.damage || result.heal,
      skillName: action.skill?.name,
      duration: 1000
    });
    
    // çµæœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    if (result.damage) {
      this.addMessage('damage', { damage: result.damage });
    }
    if (result.heal) {
      this.addMessage('heal', { heal: result.heal });
    }
    
    this.events.emit('action-executed', { action, result });
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿ
    await this.playAnimations();
    
    // æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã¸
    await this.advanceTurn();
  }
  
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿ
  private async playAnimations(): Promise<void> {
    const queue = this.state.getState().animationQueue;
    
    for (const animation of queue) {
      this.state.setState(prev => ({
        ...prev,
        phase: 'animating',
        currentAnimation: animation
      }));
      
      this.events.emit('animation-started', animation);
      
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“å¾…æ©Ÿ
      await this.wait(animation.duration);
      
      this.events.emit('animation-completed', animation);
    }
    
    // ã‚­ãƒ¥ãƒ¼ã‚¯ãƒªã‚¢
    this.state.setState(prev => ({
      ...prev,
      currentAnimation: null,
      animationQueue: []
    }));
  }
  
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚­ãƒ¥ãƒ¼è¿½åŠ 
  private queueAnimation(animation: BattleAnimation): void {
    this.state.setState(prev => ({
      ...prev,
      animationQueue: [...prev.animationQueue, animation]
    }));
  }
  
  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¿½åŠ 
  private addMessage(type: BattleMessageType, data: BattleMessageData): void {
    const message: BattleMessage = {
      id: `msg-${Date.now()}`,
      type,
      data,
      timestamp: Date.now()
    };
    
    this.state.setState(prev => ({
      ...prev,
      messages: [...prev.messages, message]
    }));
    
    this.events.emit('message-added', message);
  }
  
  // æˆ¦é—˜çµ‚äº†
  private async endBattle(result: 'victory' | 'defeat' | 'escaped'): Promise<void> {
    const rewards = result === 'victory' ? this.service.endBattle() : null;
    
    this.state.setState(prev => ({
      ...prev,
      phase: 'ended',
      result,
      rewards,
      isWaitingForInput: false
    }));
    
    this.events.emit('battle-ended', { result, rewards });
    
    this.addMessage('battle-end', { result });
  }
  
  // ã‚³ãƒãƒ³ãƒ‰æ±ºå®šæ™‚ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  onCommandConfirmed(action: BattleAction): void {
    this.executeAction(action);
  }
  
  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
  private wait(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  private isPlayerCharacter(combatant: Combatant): boolean {
    return this.state.getState().playerParty.some(c => c.id === combatant.id);
  }
  
  private getActionName(action: BattleAction): string {
    if (action.type === 'attack') return 'æ”»æ’ƒ';
    if (action.type === 'skill') return action.skill?.name || 'ã‚¹ã‚­ãƒ«';
    if (action.type === 'item') return action.item?.name || 'ã‚¢ã‚¤ãƒ†ãƒ ';
    if (action.type === 'defend') return 'é˜²å¾¡';
    return 'è¡Œå‹•';
  }
  
  private getAnimationType(action: BattleAction): BattleAnimation['type'] {
    if (action.type === 'skill') return 'skill';
    return 'damage';
  }
}
```

### ä½¿ç”¨ä¾‹ï¼ˆReactï¼‰

```typescript
// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆé–¢æ•°ï¼ˆã‚²ãƒ¼ãƒ ã”ã¨ã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ï¼‰
function formatBattleMessage(message: BattleMessage): string {
  switch (message.type) {
    case 'battle-start':
      return 'æˆ¦é—˜é–‹å§‹ï¼';
    case 'action-execute':
      return `${message.data.actorName}ã®${message.data.actionName}ï¼`;
    case 'damage':
      return `${message.data.damage}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`;
    case 'heal':
      return `${message.data.heal}å›å¾©ï¼`;
    case 'battle-end':
      if (message.data.result === 'victory') return 'å‹åˆ©ï¼';
      if (message.data.result === 'defeat') return 'å…¨æ»…...';
      if (message.data.result === 'escaped') return 'é€ƒã’å‡ºã—ãŸï¼';
      return 'æˆ¦é—˜çµ‚äº†';
    case 'turn-start':
      return `ã‚¿ãƒ¼ãƒ³${message.data.turnNumber}`;
    default:
      return '';
  }
}

function BattleScreen() {
  const [state, setState] = useState<BattleUIState>();
  const controllerRef = useRef<BattleController>();
  
  useEffect(() => {
    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼åˆæœŸåŒ–
    const service = new BattleService(coreEngine);
    const controller = new BattleController(service);
    controllerRef.current = controller;
    
    // çŠ¶æ…‹è³¼èª­
    const unsubscribe = controller.subscribe(setState);
    
    // ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­
    const unsubscribeMessage = controller.on('message-added', (msg) => {
      console.log('New message:', formatBattleMessage(msg));
    });
    
    // æˆ¦é—˜é–‹å§‹
    controller.startBattle(party, enemies);
    
    return () => {
      unsubscribe();
      unsubscribeMessage();
    };
  }, []);
  
  if (!state) return <div>Loading...</div>;
  
  // æœ€æ–°ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—ã—ã¦ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
  const currentMessage = state.messages.length > 0 
    ? formatBattleMessage(state.messages[state.messages.length - 1])
    : null;
  
  return (
    <div className="battle-screen">
      <BattleField 
        playerParty={state.playerParty}
        enemyGroup={state.enemyGroup}
        currentAnimation={state.currentAnimation}
      />
      
      <MessageBox message={currentMessage} />
      
      {state.phase === 'selecting-command' && state.isWaitingForInput && (
        <CommandMenu
          actor={state.currentActor}
          onConfirm={(action) => controllerRef.current?.onCommandConfirmed(action)}
        />
      )}
      
      {state.phase === 'ended' && state.result && (
        <BattleResult result={state.result} rewards={state.rewards} />
      )}
    </div>
  );
}
```

### ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

æ–°ã—ã„`BattleMessage`æ§‹é€ ã§ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—ã¨ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†é›¢ã™ã‚‹ã“ã¨ã§ã€å„ã‚²ãƒ¼ãƒ ãŒç‹¬è‡ªã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’å®Ÿè£…ã§ãã¾ã™ã€‚

**åˆ©ç‚¹ï¼š**

1. **å¤šè¨€èªå¯¾å¿œ**: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—ã¨ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å„è¨€èªã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆå¯èƒ½
2. **è¡¨ç¾ã®è‡ªç”±åº¦**: åŒã˜ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç•°ãªã‚‹ã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆå¯èƒ½
3. **æ‹¡å¼µæ€§**: æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—ã‚’è¿½åŠ ã—ã‚„ã™ã„
4. **ãƒ­ã‚°åˆ†æ**: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—ã§æˆ¦é—˜ãƒ­ã‚°ã‚’åˆ†æå¯èƒ½

**ä½¿ç”¨ä¾‹ï¼šç•°ãªã‚‹ã‚¹ã‚¿ã‚¤ãƒ«**

```typescript
// ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«ãªã‚¹ã‚¿ã‚¤ãƒ«
function formatCasual(message: BattleMessage): string {
  switch (message.type) {
    case 'action-execute':
      return `${message.data.actorName}ãŒ${message.data.actionName}ã‚’ä½¿ã£ãŸï¼`;
    case 'damage':
      return `${message.data.damage}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`;
    // ...
  }
}

// ãƒ•ã‚©ãƒ¼ãƒãƒ«ãªã‚¹ã‚¿ã‚¤ãƒ«
function formatFormal(message: BattleMessage): string {
  switch (message.type) {
    case 'action-execute':
      return `${message.data.actorName}ã¯${message.data.actionName}ã‚’å®Ÿè¡Œã—ã¾ã—ãŸã€‚`;
    case 'damage':
      return `${message.data.damage}ãƒã‚¤ãƒ³ãƒˆã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã—ãŸã€‚`;
    // ...
  }
}

// è‹±èªç‰ˆ
function formatEnglish(message: BattleMessage): string {
  switch (message.type) {
    case 'action-execute':
      return `${message.data.actorName} used ${message.data.actionName}!`;
    case 'damage':
      return `${message.data.damage} damage!`;
    // ...
  }
}
```



---

## 2. CommandController - ã‚³ãƒãƒ³ãƒ‰é¸æŠUIåˆ¶å¾¡

### çŠ¶æ…‹å®šç¾©

```typescript
interface CommandUIState {
  // é¸æŠæ®µéš
  stage: 'selecting-command' | 'selecting-skill' | 'selecting-item' | 'selecting-target' | 'confirmed';
  
  // ç¾åœ¨ã®ã‚¢ã‚¯ã‚¿ãƒ¼
  actor: Character | null;
  
  // é¸æŠè‚¢
  availableCommands: CommandOption[];
  availableSkills: Skill[];
  availableItems: Item[];
  availableTargets: Combatant[];
  
  // é¸æŠä¸­
  selectedCommand: string | null;
  selectedSkill: Skill | null;
  selectedItem: Item | null;
  selectedTargets: Combatant[];
  
  // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®
  cursorIndex: number;
  
  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æƒ…å ±
  damagePreview: number | null;
  targetPreview: Combatant | null;
}
```

### ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼å®Ÿè£…

```typescript
type CommandEvents = {
  'command-selected': { command: string };
  'skill-selected': { skill: Skill };
  'item-selected': { item: Item };
  'target-selected': { target: Combatant };
  'command-confirmed': { action: BattleAction };
  'command-cancelled': {};
};

class CommandController {
  private state: ObservableState<CommandUIState>;
  private events: EventEmitter<CommandEvents>;
  private service: CommandService;
  
  constructor(service: CommandService) {
    this.service = service;
    this.state = new ObservableState<CommandUIState>({
      stage: 'selecting-command',
      actor: null,
      availableCommands: [],
      availableSkills: [],
      availableItems: [],
      availableTargets: [],
      selectedCommand: null,
      selectedSkill: null,
      selectedItem: null,
      selectedTargets: [],
      cursorIndex: 0,
      damagePreview: null,
      targetPreview: null
    });
    this.events = new EventEmitter<CommandEvents>();
  }
  
  subscribe(listener: (state: CommandUIState) => void): () => void {
    return this.state.subscribe(listener);
  }
  
  on<K extends keyof CommandEvents>(
    event: K,
    listener: (data: CommandEvents[K]) => void
  ): () => void {
    return this.events.on(event, listener);
  }
  
  // ã‚³ãƒãƒ³ãƒ‰é¸æŠé–‹å§‹
  startCommandSelection(actor: Character): void {
    const availableCommands = this.service.getAvailableCommands(actor);
    
    this.state.setState({
      stage: 'selecting-command',
      actor,
      availableCommands,
      availableSkills: [],
      availableItems: [],
      availableTargets: [],
      selectedCommand: null,
      selectedSkill: null,
      selectedItem: null,
      selectedTargets: [],
      cursorIndex: 0,
      damagePreview: null,
      targetPreview: null
    });
  }
  
  // ã‚³ãƒãƒ³ãƒ‰é¸æŠ
  selectCommand(command: string): void {
    this.service.selectCommand(command);
    
    this.state.setState(prev => ({
      ...prev,
      selectedCommand: command
    }));
    
    this.events.emit('command-selected', { command });
    
    // æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸
    switch (command) {
      case 'attack':
        this.moveToTargetSelection();
        break;
      case 'skill':
        this.moveToSkillSelection();
        break;
      case 'item':
        this.moveToItemSelection();
        break;
      case 'defend':
      case 'escape':
        this.confirm();
        break;
    }
  }
  
  // ã‚¹ã‚­ãƒ«é¸æŠã¸ç§»å‹•
  private moveToSkillSelection(): void {
    const actor = this.state.getState().actor!;
    const availableSkills = this.service.getUsableSkills(actor);
    
    this.state.setState(prev => ({
      ...prev,
      stage: 'selecting-skill',
      availableSkills,
      cursorIndex: 0
    }));
  }
  
  // ã‚¹ã‚­ãƒ«é¸æŠ
  selectSkill(skill: Skill): void {
    this.service.selectSkill(skill);
    
    this.state.setState(prev => ({
      ...prev,
      selectedSkill: skill
    }));
    
    this.events.emit('skill-selected', { skill });
    this.moveToTargetSelection();
  }
  
  // ã‚¢ã‚¤ãƒ†ãƒ é¸æŠã¸ç§»å‹•
  private moveToItemSelection(): void {
    const availableItems = this.service.getUsableItemsInBattle();
    
    this.state.setState(prev => ({
      ...prev,
      stage: 'selecting-item',
      availableItems,
      cursorIndex: 0
    }));
  }
  
  // ã‚¢ã‚¤ãƒ†ãƒ é¸æŠ
  selectItem(item: Item): void {
    this.service.selectItem(item);
    
    this.state.setState(prev => ({
      ...prev,
      selectedItem: item
    }));
    
    this.events.emit('item-selected', { item });
    this.moveToTargetSelection();
  }
  
  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠã¸ç§»å‹•
  private moveToTargetSelection(): void {
    const availableTargets = this.service.getAvailableTargets();
    
    this.state.setState(prev => ({
      ...prev,
      stage: 'selecting-target',
      availableTargets,
      cursorIndex: 0
    }));
  }
  
  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠ
  selectTarget(target: Combatant): void {
    this.service.selectTarget(target);
    
    this.state.setState(prev => ({
      ...prev,
      selectedTargets: [target],
      targetPreview: target
    }));
    
    this.events.emit('target-selected', { target });
  }
  
  // ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•
  moveCursor(delta: number): void {
    const currentState = this.state.getState();
    let maxIndex = 0;
    
    switch (currentState.stage) {
      case 'selecting-command':
        maxIndex = currentState.availableCommands.length - 1;
        break;
      case 'selecting-skill':
        maxIndex = currentState.availableSkills.length - 1;
        break;
      case 'selecting-item':
        maxIndex = currentState.availableItems.length - 1;
        break;
      case 'selecting-target':
        maxIndex = currentState.availableTargets.length - 1;
        break;
    }
    
    const newIndex = Math.max(0, Math.min(maxIndex, currentState.cursorIndex + delta));
    
    this.state.setState(prev => ({
      ...prev,
      cursorIndex: newIndex
    }));
    
    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠæ™‚ã¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
    if (currentState.stage === 'selecting-target') {
      const target = currentState.availableTargets[newIndex];
      this.updateDamagePreview(target);
    }
  }
  
  // ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
  private updateDamagePreview(target: Combatant): void {
    const actor = this.state.getState().actor!;
    const skill = this.state.getState().selectedSkill;
    
    if (!skill) return;
    
    // Core Engineã§ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ï¼‰
    const damagePreview = this.service.previewDamage(actor, target, skill);
    
    this.state.setState(prev => ({
      ...prev,
      damagePreview,
      targetPreview: target
    }));
  }
  
  // æ±ºå®š
  confirm(): void {
    const action = this.service.confirm();
    
    this.state.setState(prev => ({
      ...prev,
      stage: 'confirmed'
    }));
    
    this.events.emit('command-confirmed', { action });
  }
  
  // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  cancel(): void {
    this.service.cancel();
    
    const currentState = this.state.getState();
    
    // ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’1ã¤æˆ»ã™
    switch (currentState.stage) {
      case 'selecting-skill':
      case 'selecting-item':
        this.state.setState(prev => ({
          ...prev,
          stage: 'selecting-command',
          selectedCommand: null,
          cursorIndex: 0
        }));
        break;
        
      case 'selecting-target':
        if (currentState.selectedSkill) {
          this.state.setState(prev => ({
            ...prev,
            stage: 'selecting-skill',
            selectedSkill: null,
            selectedTargets: [],
            cursorIndex: 0
          }));
        } else if (currentState.selectedItem) {
          this.state.setState(prev => ({
            ...prev,
            stage: 'selecting-item',
            selectedItem: null,
            selectedTargets: [],
            cursorIndex: 0
          }));
        } else {
          this.state.setState(prev => ({
            ...prev,
            stage: 'selecting-command',
            selectedCommand: null,
            selectedTargets: [],
            cursorIndex: 0
          }));
        }
        break;
    }
    
    this.events.emit('command-cancelled', {});
  }
}
```

---

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### å˜ä½“ãƒ†ã‚¹ãƒˆ (Unit Tests)

#### Core Engineå±¤ã®ãƒ†ã‚¹ãƒˆ
**å¯¾è±¡ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«**: `combat/`

- **ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—ãƒ†ã‚¹ãƒˆ**
  - ç‰©ç†æ”»æ’ƒã®ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—ãŒæ­£ã—ã„ã“ã¨
  - é­”æ³•æ”»æ’ƒã®ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—ãŒæ­£ã—ã„ã“ã¨
  - é˜²å¾¡åŠ›ã«ã‚ˆã‚‹è»½æ¸›ãŒæ­£ã—ãæ©Ÿèƒ½ã™ã‚‹ã“ã¨
  - ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ’ãƒƒãƒˆæ™‚ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å€ç‡ãŒæ­£ã—ã„ã“ã¨
  - å±æ€§ç›¸æ€§ã«ã‚ˆã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸è£œæ­£ãŒæ­£ã—ã„ã“ã¨

- **å‘½ä¸­åˆ¤å®šãƒ†ã‚¹ãƒˆ**
  - å‘½ä¸­ç‡ã®è¨ˆç®—ãŒæ­£ã—ã„ã“ã¨
  - å›é¿ç‡ã®è¨ˆç®—ãŒæ­£ã—ã„ã“ã¨
  - ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«åˆ¤å®šãŒæ­£ã—ãæ©Ÿèƒ½ã™ã‚‹ã“ã¨
  - å¿…ä¸­æ”»æ’ƒãŒæ©Ÿèƒ½ã™ã‚‹ã“ã¨

- **è¡Œå‹•é †è¨ˆç®—ãƒ†ã‚¹ãƒˆ**
  - ç´ æ—©ã•ã«åŸºã¥ãè¡Œå‹•é †ãŒæ­£ã—ã„ã“ã¨
  - å…ˆåˆ¶æ”»æ’ƒåˆ¤å®šãŒæ­£ã—ã„ã“ã¨
  - åŒé€Ÿæ™‚ã®å‡¦ç†ãŒé©åˆ‡ã§ã‚ã‚‹ã“ã¨

- **å‹æ•—åˆ¤å®šãƒ†ã‚¹ãƒˆ**
  - å…¨æ»…åˆ¤å®šãŒæ­£ã—ã„ã“ã¨
  - å‹åˆ©æ¡ä»¶åˆ¤å®šãŒæ­£ã—ã„ã“ã¨
  - é€ƒèµ°æˆåŠŸç‡ã®è¨ˆç®—ãŒæ­£ã—ã„ã“ã¨

#### Serviceå±¤ã®ãƒ†ã‚¹ãƒˆ
**å¯¾è±¡Service**: `BattleService`, `CommandService`

- **BattleServiceã®ãƒ†ã‚¹ãƒˆ**
  - æˆ¦é—˜ã®åˆæœŸåŒ–ãŒæ­£ã—ãè¡Œã‚ã‚Œã‚‹ã“ã¨
  - ã‚¿ãƒ¼ãƒ³é€²è¡ŒãŒæ­£ã—ãæ©Ÿèƒ½ã™ã‚‹ã“ã¨
  - ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»ãŒé©åˆ‡ã§ã‚ã‚‹ã“ã¨
  - æˆ¦é—˜çµ‚äº†åˆ¤å®šãŒæ­£ã—ã„ã“ã¨
  - å ±é…¬è¨ˆç®—ãŒæ­£ã—ã„ã“ã¨

- **CommandServiceã®ãƒ†ã‚¹ãƒˆ**
  - ã‚³ãƒãƒ³ãƒ‰é¸æŠè‚¢ãŒæ­£ã—ãæç¤ºã•ã‚Œã‚‹ã“ã¨
  - ä½¿ç”¨ä¸å¯ã‚³ãƒãƒ³ãƒ‰ãŒç„¡åŠ¹åŒ–ã•ã‚Œã‚‹ã“ã¨
  - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠãŒæ­£ã—ãæ©Ÿèƒ½ã™ã‚‹ã“ã¨
  - ã‚­ãƒ£ãƒ³ã‚»ãƒ«å‡¦ç†ãŒé©åˆ‡ã§ã‚ã‚‹ã“ã¨
  - è¡Œå‹•ç¢ºå®šæ™‚ã®ãƒ‡ãƒ¼ã‚¿ãŒæ­£ã—ã„ã“ã¨

#### Headless UIå±¤ã®ãƒ†ã‚¹ãƒˆ
**å¯¾è±¡Controller**: `BattleController`, `CommandController`

- **BattleControllerã®ãƒ†ã‚¹ãƒˆ**
  - çŠ¶æ…‹æ›´æ–°ãŒæ­£ã—ãè¡Œã‚ã‚Œã‚‹ã“ã¨
  - ã‚¤ãƒ™ãƒ³ãƒˆé€šçŸ¥ãŒé©åˆ‡ã§ã‚ã‚‹ã“ã¨
  - UIçŠ¶æ…‹ã®æ•´åˆæ€§ãŒä¿ãŸã‚Œã‚‹ã“ã¨

- **CommandControllerã®ãƒ†ã‚¹ãƒˆ**
  - ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•ãŒæ­£ã—ãæ©Ÿèƒ½ã™ã‚‹ã“ã¨
  - é¸æŠçŠ¶æ…‹ã®ç®¡ç†ãŒé©åˆ‡ã§ã‚ã‚‹ã“ã¨
  - ã‚¤ãƒ™ãƒ³ãƒˆã‚¨ãƒŸãƒƒãƒˆãŒæ­£ã—ã„ã“ã¨

### çµ±åˆãƒ†ã‚¹ãƒˆ (Integration Tests)

#### æˆ¦é—˜ãƒ•ãƒ­ãƒ¼å…¨ä½“ã®ãƒ†ã‚¹ãƒˆ
- **åŸºæœ¬æˆ¦é—˜ã‚·ãƒŠãƒªã‚ª**
  - æˆ¦é—˜é–‹å§‹â†’ã‚³ãƒãƒ³ãƒ‰é¸æŠâ†’æ”»æ’ƒâ†’æ•µã‚¿ãƒ¼ãƒ³â†’å‹åˆ©ã¾ã§ã®æµã‚Œ
  - è¤‡æ•°ã‚¿ãƒ¼ãƒ³ã«ã‚ãŸã‚‹æˆ¦é—˜ãŒæ­£ã—ãé€²è¡Œã™ã‚‹ã“ã¨
  - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨æ•µãŒäº¤äº’ã«è¡Œå‹•ã™ã‚‹ã“ã¨

- **ç‰¹æ®Šæˆ¦é—˜ã‚·ãƒŠãƒªã‚ª**
  - ã‚¹ã‚­ãƒ«ä½¿ç”¨ã®æµã‚ŒãŒæ­£ã—ã„ã“ã¨
  - ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨ã®æµã‚ŒãŒæ­£ã—ã„ã“ã¨
  - é˜²å¾¡ã‚³ãƒãƒ³ãƒ‰ãŒæ©Ÿèƒ½ã™ã‚‹ã“ã¨
  - é€ƒèµ°ãŒæˆåŠŸ/å¤±æ•—ã™ã‚‹ã“ã¨

- **çŠ¶æ…‹ç•°å¸¸ã‚’å«ã‚€æˆ¦é—˜**
  - æ¯’çŠ¶æ…‹ã§ã®ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ãŒç™ºç”Ÿã™ã‚‹ã“ã¨
  - éº»ç—ºçŠ¶æ…‹ã§è¡Œå‹•ä¸èƒ½ã«ãªã‚‹ã“ã¨
  - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰åŒ–ãŒæˆ¦é—˜ã«å½±éŸ¿ã™ã‚‹ã“ã¨

#### Serviceé–“ã®é€£æºãƒ†ã‚¹ãƒˆ
- BattleService + CommandService ã®é€£æº
- BattleService + EnemyAIService ã®é€£æº
- BattleService + StatusEffectService ã®é€£æº

### E2Eãƒ†ã‚¹ãƒˆ (End-to-End Tests)

#### å®Ÿæˆ¦çš„ãªæˆ¦é—˜ã‚·ãƒŠãƒªã‚ª
- **ç°¡å˜ãªæˆ¦é—˜**
  - ä½ãƒ¬ãƒ™ãƒ«æ•µã¨ã®æˆ¦é—˜ãŒã‚¹ãƒ ãƒ¼ã‚ºã«å®Œäº†ã™ã‚‹ã“ã¨
  - å ±é…¬ã‚’æ­£ã—ãå—ã‘å–ã‚Œã‚‹ã“ã¨

- **é›£æ˜“åº¦ã®é«˜ã„æˆ¦é—˜**
  - è¤‡æ•°ã®æ•µã¨ã®æˆ¦é—˜ãŒæ­£ã—ãæ©Ÿèƒ½ã™ã‚‹ã“ã¨
  - æˆ¦ç•¥çš„ãªã‚³ãƒãƒ³ãƒ‰é¸æŠãŒå¯èƒ½ã§ã‚ã‚‹ã“ã¨
  - å…¨æ»…æ™‚ã®å‡¦ç†ãŒæ­£ã—ã„ã“ã¨

- **é•·æœŸæˆ¦**
  - å¤šæ•°ã®ã‚¿ãƒ¼ãƒ³ã«ã‚ãŸã‚‹æˆ¦é—˜ãŒå®‰å®šã™ã‚‹ã“ã¨
  - ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãŒãªã„ã“ã¨
  - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒåŠ£åŒ–ã—ãªã„ã“ã¨

### ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™

| å±¤ | ç›®æ¨™ã‚«ãƒãƒ¬ãƒƒã‚¸ | å„ªå…ˆåº¦ |
|----|--------------|-------|
| Core Engineå±¤ | 90%ä»¥ä¸Š | æœ€é«˜ |
| Serviceå±¤ | 85%ä»¥ä¸Š | é«˜ |
| Headless UIå±¤ | 75%ä»¥ä¸Š | ä¸­ |

### ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿

#### ãƒ†ã‚¹ãƒˆç”¨ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
```typescript
// åŸºæœ¬ãƒ†ã‚¹ãƒˆç”¨ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
const testCharacter: Character = {
  id: 'test-char-1',
  name: 'ãƒ†ã‚¹ãƒˆå‹‡è€…',
  level: 10,
  stats: {
    maxHp: 100,
    maxMp: 50,
    attack: 30,
    defense: 20,
    magicAttack: 25,
    magicDefense: 18,
    speed: 15
  },
  currentHp: 100,
  currentMp: 50,
  skills: [testSkill],
  statusEffects: []
};

// ãƒ†ã‚¹ãƒˆç”¨æ•µ
const testEnemy: Enemy = {
  id: 'test-enemy-1',
  name: 'ãƒ†ã‚¹ãƒˆã‚¹ãƒ©ã‚¤ãƒ ',
  level: 5,
  stats: {
    maxHp: 50,
    maxMp: 10,
    attack: 15,
    defense: 10,
    magicAttack: 5,
    magicDefense: 8,
    speed: 8
  },
  currentHp: 50,
  currentMp: 10,
  skills: [],
  aiStrategy: 'aggressive'
};
```


