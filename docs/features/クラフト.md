# ã‚¯ãƒ©ãƒ•ãƒˆã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ

ã‚¢ã‚¤ãƒ†ãƒ åˆæˆã«é–¢ã™ã‚‹è¨­è¨ˆã€‚Core Engineã€Serviceã€Headless UIã®3å±¤ã§æ§‹æˆã€‚

## ç›®æ¬¡

1. [æ¦‚è¦](#æ¦‚è¦)
2. [Core Engineå±¤](#core-engineå±¤)
3. [Serviceå±¤](#serviceå±¤)
4. [Headless UIå±¤](#headless-uiå±¤)

---

## æ¦‚è¦

### 3å±¤ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Headless UI Layer                  â”‚
â”‚  Controller                         â”‚  â† UIçŠ¶æ…‹ç®¡ç†ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ å§”è­²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Service Layer                      â”‚
â”‚  Service                            â”‚  â† ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ å§”è­²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Core Engine Layer                  â”‚
â”‚  ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«                          â”‚  â† ç´”ç²‹ãªè¨ˆç®—
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Core Engineå±¤

### ğŸ›  ã‚¯ãƒ©ãƒ•ãƒˆãƒ»å¼·åŒ–ã«é–¢ã™ã‚‹è¨ˆç®—

#### ã‚¢ã‚¤ãƒ†ãƒ åˆæˆ
- ç´ æã®æ‰€æŒãƒã‚§ãƒƒã‚¯
  - å¿…è¦ç´ æã®ç¢ºèª
  - ç´ æã®å€‹æ•°ãƒã‚§ãƒƒã‚¯
- æˆåŠŸç‡ã®è¨ˆç®—
  - åŸºæœ¬æˆåŠŸç‡
  - ã‚¹ã‚­ãƒ«ã«ã‚ˆã‚‹è£œæ­£
  - ã‚¢ã‚¤ãƒ†ãƒ ã«ã‚ˆã‚‹ãƒœãƒ¼ãƒŠã‚¹
- çµæœã‚¢ã‚¤ãƒ†ãƒ ã®ç”Ÿæˆ
  - é€šå¸¸æˆåŠŸæ™‚ã®ã‚¢ã‚¤ãƒ†ãƒ 
  - å¤§æˆåŠŸæ™‚ã®ãƒœãƒ¼ãƒŠã‚¹
  - å¤±æ•—æ™‚ã®ç´ æè¿”é‚„åˆ¤å®š
- ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã®æ›´æ–°
  - ç´ æã®æ¶ˆè²»
  - å®Œæˆå“ã®è¿½åŠ 

#### è£…å‚™ãƒ»ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å¼·åŒ–
- æˆåŠŸç‡ã®è¨ˆç®—
  - å¼·åŒ–ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸæˆåŠŸç‡
  - å®‰å…¨åœã®åˆ¤å®š
  - å¤±æ•—æ™‚ã®ãƒšãƒŠãƒ«ãƒ†ã‚£åˆ¤å®š
- èƒ½åŠ›å€¤ä¸Šæ˜‡ã®è¨ˆç®—
  - å¼·åŒ–ã«ã‚ˆã‚‹ä¸Šæ˜‡å€¤
  - ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ 
  - ä¸Šé™å€¤ã®åˆ¤å®š
- ã‚³ã‚¹ãƒˆã®æ¶ˆè²»å‡¦ç†
  - å¼·åŒ–ç´ æã®æ¶ˆè²»
  - ãŠé‡‘ã®æ¶ˆè²»


---

## Serviceå±¤

---

## 13. CraftService - ã‚¢ã‚¤ãƒ†ãƒ åˆæˆç®¡ç†

### æ¦‚è¦
ã‚¢ã‚¤ãƒ†ãƒ åˆæˆã®æµã‚Œã‚’ç®¡ç†ã€‚ãƒ¬ã‚·ãƒ”ç¢ºèªã€ææ–™ãƒã‚§ãƒƒã‚¯ã€åˆæˆå®Ÿè¡Œã€ãƒ¬ã‚·ãƒ”è§£æ”¾ã‚’è¡Œã†ã€‚

### å…¬é–‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
class CraftService {
  // è§£æ”¾æ¸ˆã¿ãƒ¬ã‚·ãƒ”å–å¾—
  getUnlockedRecipes(gameState: GameState): Recipe[];
  
  // ææ–™ãƒã‚§ãƒƒã‚¯
  checkMaterials(recipe: Recipe, inventory: Inventory): RecipeCheckResult;
  
  // åˆæˆå®Ÿè¡Œ
  synthesize(recipe: Recipe, inventory: Inventory, gameState: GameState): SynthesisResult;
  
  // ãƒ¬ã‚·ãƒ”è§£æ”¾æ¡ä»¶ãƒã‚§ãƒƒã‚¯
  checkRecipeUnlockCondition(recipe: Recipe, gameState: GameState, party: Character[]): boolean;
  
  // ãƒ¬ã‚·ãƒ”è§£æ”¾
  unlockRecipe(recipeId: UniqueId, gameState: GameState, trigger?: string): void;
  
  // æœªè§£æ”¾ãƒ¬ã‚·ãƒ”ã§è§£æ”¾å¯èƒ½ãªã‚‚ã®ã‚’å–å¾—
  getUnlockableRecipes(gameState: GameState, party: Character[]): Recipe[];
}
```

### Core Engine å§”è­²

- `craft/synthesis.checkRecipeRequirements()` - ãƒ¬ã‚·ãƒ”ææ–™ãƒã‚§ãƒƒã‚¯
- `craft/synthesis.calculateSynthesisSuccessRate()` - æˆåŠŸç‡è¨ˆç®—
- `craft/synthesis.rollSynthesisResult()` - åˆæˆçµæœåˆ¤å®š
- `craft/synthesis.calculateMaterialReturn()` - ææ–™è¿”é‚„åˆ¤å®š
- `craft/synthesis.checkRecipeUnlockCondition()` - ãƒ¬ã‚·ãƒ”è§£æ”¾æ¡ä»¶ãƒã‚§ãƒƒã‚¯
- `craft/synthesis.getUnlockedRecipes()` - è§£æ”¾æ¸ˆã¿ãƒ¬ã‚·ãƒ”å–å¾—
- `craft/synthesis.unlockRecipe()` - ãƒ¬ã‚·ãƒ”è§£æ”¾
- `craft/synthesis.checkAllRecipeUnlockConditions()` - å…¨ãƒ¬ã‚·ãƒ”è§£æ”¾å¯å¦ãƒã‚§ãƒƒã‚¯

### å®Ÿè£…ä¾‹

```typescript
class CraftService {
  constructor(
    private coreEngine: CoreEngine,
    private inventoryService: InventoryService
  ) {}
  
  getUnlockedRecipes(gameState: GameState): Recipe[] {
    // Core Engineã§è§£æ”¾æ¸ˆã¿ãƒ¬ã‚·ãƒ”ã‚’å–å¾—
    return this.coreEngine.getUnlockedRecipes(
      this.coreEngine.getAllRecipes(),
      gameState
    );
  }
  
  checkMaterials(recipe: Recipe, inventory: Inventory): RecipeCheckResult {
    // Core Engineã§ææ–™ãƒã‚§ãƒƒã‚¯
    return this.coreEngine.checkRecipeRequirements(recipe, inventory);
  }
  
  checkRecipeUnlockCondition(
    recipe: Recipe,
    gameState: GameState,
    party: Character[]
  ): boolean {
    // ãƒ¬ã‚·ãƒ”è§£æ”¾æ¡ä»¶ã®ãƒã‚§ãƒƒã‚¯
    return this.coreEngine.checkRecipeUnlockCondition(recipe, gameState, party);
  }
  
  unlockRecipe(recipeId: UniqueId, gameState: GameState, trigger?: string): void {
    // ãƒ¬ã‚·ãƒ”ã‚’è§£æ”¾
    this.coreEngine.unlockRecipe(recipeId, gameState, trigger);
    
    // ä½œæˆå›æ•°ã‚’åˆæœŸåŒ–
    if (!gameState.craftHistory.has(recipeId)) {
      gameState.craftHistory.set(recipeId, 0);
    }
  }
  
  getUnlockableRecipes(gameState: GameState, party: Character[]): Recipe[] {
    // æœªè§£æ”¾ã§è§£æ”¾å¯èƒ½ãªãƒ¬ã‚·ãƒ”ã‚’å–å¾—
    const allRecipes = this.coreEngine.getAllRecipes();
    const unlockableRecipes: Recipe[] = [];
    
    for (const recipe of allRecipes) {
      // ã™ã§ã«è§£æ”¾æ¸ˆã¿ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
      if (gameState.unlockedRecipes.has(recipe.id)) {
        continue;
      }
      
      // è§£æ”¾æ¡ä»¶ãƒã‚§ãƒƒã‚¯
      if (this.checkRecipeUnlockCondition(recipe, gameState, party)) {
        unlockableRecipes.push(recipe);
      }
    }
    
    return unlockableRecipes;
  }
  
  synthesize(
    recipe: Recipe,
    inventory: Inventory,
    gameState: GameState
  ): SynthesisResult {
    // ãƒ¬ã‚·ãƒ”è§£æ”¾ãƒã‚§ãƒƒã‚¯
    if (!gameState.unlockedRecipes.has(recipe.id) && !recipe.isUnlockedByDefault) {
      return {
        success: false,
        message: 'ã“ã®ãƒ¬ã‚·ãƒ”ã¯ã¾ã è§£æ”¾ã•ã‚Œã¦ã„ã¾ã›ã‚“',
        outcome: 'failure'
      };
    }
    
    // ææ–™ãƒã‚§ãƒƒã‚¯
    const materialCheck = this.checkMaterials(recipe, inventory);
    if (!materialCheck.canCraft) {
      return {
        success: false,
        message: 'ææ–™ãŒä¸è¶³ã—ã¦ã„ã¾ã™',
        missingMaterials: materialCheck.missingMaterials,
        outcome: 'failure'
      };
    }
    
    // æˆåŠŸç‡è¨ˆç®—
    const successRate = this.coreEngine.calculateSynthesisSuccessRate(recipe);
    
    // åˆæˆåˆ¤å®š
    const result = this.coreEngine.rollSynthesisResult(recipe, successRate);
    
    // ææ–™æ¶ˆè²»
    for (const material of recipe.requiredMaterials) {
      this.inventoryService.removeItem(material.itemId, material.quantity);
    }
    
    // ä½œæˆå›æ•°ã‚’è¨˜éŒ²
    const currentCount = gameState.craftHistory.get(recipe.resultItem.id) || 0;
    gameState.craftHistory.set(recipe.resultItem.id, currentCount + 1);
    
    if (result.outcome === 'success' || result.outcome === 'great-success') {
      // æˆåŠŸï¼šç”Ÿæˆç‰©ã‚’è¿½åŠ 
      const quantity = result.outcome === 'great-success' ? 
        recipe.resultQuantity * 2 : recipe.resultQuantity;
      
      this.inventoryService.addItem(recipe.resultItem.id, quantity);
      
      // ãƒœãƒ¼ãƒŠã‚¹ã‚¢ã‚¤ãƒ†ãƒ 
      if (result.bonusItems && result.bonusItems.length > 0) {
        for (const bonus of result.bonusItems) {
          this.inventoryService.addItem(bonus.item.id, bonus.quantity);
        }
      }
      
      return {
        success: true,
        message: `${recipe.resultItem.name}ã®åˆæˆã«æˆåŠŸã—ã¾ã—ãŸï¼`,
        outcome: result.outcome,
        itemsProduced: [{ item: recipe.resultItem, quantity }],
        bonusItems: result.bonusItems
      };
    } else {
      // å¤±æ•—ï¼šææ–™ã®ä¸€éƒ¨è¿”é‚„åˆ¤å®š
      const returnedMaterials = this.coreEngine.calculateMaterialReturn(recipe);
      for (const material of returnedMaterials) {
        this.inventoryService.addItem(material.item.id, material.quantity);
      }
      
      return {
        success: false,
        message: 'åˆæˆã«å¤±æ•—ã—ã¾ã—ãŸ...',
        outcome: 'failure',
        materialsReturned: returnedMaterials
      };
    }
  }
}
```

### ãƒ¬ã‚·ãƒ”è§£æ”¾æ¡ä»¶ã®ä¾‹

```typescript
// ä¾‹1: ãƒ¬ãƒ™ãƒ«æ¡ä»¶
const basicPotionRecipe: Recipe = {
  id: 'recipe_basic_potion',
  name: 'åŸºæœ¬ãƒãƒ¼ã‚·ãƒ§ãƒ³',
  // ... ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  isUnlockedByDefault: true  // æœ€åˆã‹ã‚‰ä½¿ãˆã‚‹
};

// ä¾‹2: ã‚¯ã‚¨ã‚¹ãƒˆã‚¯ãƒªã‚¢æ¡ä»¶
const advancedPotionRecipe: Recipe = {
  id: 'recipe_advanced_potion',
  name: 'ä¸Šç´šãƒãƒ¼ã‚·ãƒ§ãƒ³',
  // ... ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  unlockCondition: {
    requiredQuest: 'quest_herbalist_training',
    minLevel: 10
  }
};

// ä¾‹3: è¤‡æ•°ã®ä½œæˆå®Ÿç¸¾
const masterPotionRecipe: Recipe = {
  id: 'recipe_master_potion',
  name: 'ãƒã‚¹ã‚¿ãƒ¼ãƒãƒ¼ã‚·ãƒ§ãƒ³',
  // ... ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  unlockCondition: {
    requiredCraftCount: { itemId: 'item_advanced_potion', count: 20 },
    requiredRecipesUnlocked: ['recipe_advanced_potion', 'recipe_herb_essence']
  }
};

// ä¾‹4: ã‚«ã‚¹ã‚¿ãƒ æ¡ä»¶
const legendaryWeaponRecipe: Recipe = {
  id: 'recipe_legendary_sword',
  name: 'ä¼èª¬ã®å‰£',
  // ... ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  unlockCondition: {
    customCondition: (gameState, party) => {
      // ãƒ‘ãƒ¼ãƒ†ã‚£ã«ç‰¹å®šã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒã„ã‚‹
      const hasBlacksmith = party.some(c => c.job.id === 'job_blacksmith');
      // ç‰¹å®šã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‰€æŒã—ã¦ã„ã‚‹
      const hasMythril = gameState.inventory.slots.some(
        slot => slot.item.id === 'item_mythril_ore' && slot.quantity >= 10
      );
      return hasBlacksmith && hasMythril;
    }
  }
};

// ä¾‹5: ORæ¡ä»¶ï¼ˆã„ãšã‚Œã‹ã‚’æº€ãŸã›ã°OKï¼‰
const rareRecipe: Recipe = {
  id: 'recipe_rare_item',
  name: 'ãƒ¬ã‚¢ã‚¢ã‚¤ãƒ†ãƒ ',
  // ... ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  unlockCondition: {
    orConditions: [
      { requiredAchievement: 'achievement_master_crafter' },
      { requiredStoryProgress: 'chapter_5', minLevel: 50 }
    ]
  }
};
```



---

## Headless UIå±¤

---

## 7. CraftController - ã‚¢ã‚¤ãƒ†ãƒ åˆæˆUIåˆ¶å¾¡

### çŠ¶æ…‹å®šç¾©

```typescript
interface CraftUIState {
  // é¸æŠæ®µéš
  stage: 'selecting-recipe' | 'confirming' | 'synthesizing' | 'completed' | 'viewing-locked';
  
  // ãƒ¬ã‚·ãƒ”
  unlockedRecipes: Recipe[];          // è§£æ”¾æ¸ˆã¿ãƒ¬ã‚·ãƒ”
  lockedRecipes: Recipe[];            // æœªè§£æ”¾ãƒ¬ã‚·ãƒ”ï¼ˆè§£æ”¾æ¡ä»¶è¡¨ç¤ºç”¨ï¼‰
  selectedRecipe: Recipe | null;
  
  // ææ–™ãƒã‚§ãƒƒã‚¯
  materialCheck: RecipeCheckResult | null;
  
  // åˆæˆ
  successRate: number;
  isProcessing: boolean;
  
  // çµæœ
  result: SynthesisResult | null;
  
  // ã‚«ãƒ¼ã‚½ãƒ«
  cursorIndex: number;
  
  // ãƒ•ã‚£ãƒ«ã‚¿
  categoryFilter: CraftCategory | null;
  availableOnlyFilter: boolean;
  showLockedRecipes: boolean;         // æœªè§£æ”¾ãƒ¬ã‚·ãƒ”ã‚‚è¡¨ç¤ºã™ã‚‹ã‹
  
  // ãƒ¬ã‚·ãƒ”è§£æ”¾
  unlockableRecipes: Recipe[];        // è§£æ”¾å¯èƒ½ãªãƒ¬ã‚·ãƒ”
  recentlyUnlockedRecipes: Recipe[];  // æœ€è¿‘è§£æ”¾ã•ã‚ŒãŸãƒ¬ã‚·ãƒ”ï¼ˆé€šçŸ¥ç”¨ï¼‰
}

interface RecipeCheckResult {
  recipe: Recipe;
  canCraft: boolean;
  missingMaterials: {
    item: Item;
    required: number;
    current: number;
  }[];
  availableMaterials: {
    item: Item;
    required: number;
    current: number;
  }[];
}

interface SynthesisResult {
  success: boolean;
  recipe: Recipe;
  resultItem: Item | null;
  bonusItems: Item[];
  materialsConsumed: Item[];
  materialsReturned: Item[];
  message: string;
}
```

### ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼å®Ÿè£…

```typescript
type CraftEvents = {
  'recipe-selected': { recipe: Recipe };
  'synthesis-started': { recipe: Recipe };
  'synthesis-completed': { result: SynthesisResult };
  'recipe-unlocked': { recipe: Recipe; trigger?: string };
  'recipes-auto-unlocked': { recipes: Recipe[] };
  'cancelled': {};
};

class CraftController {
  private state: ObservableState<CraftUIState>;
  private events: EventEmitter<CraftEvents>;
  private service: CraftService;
  
  constructor(
    service: CraftService,
    private inventory: Inventory,
    private gameState: GameState,
    private party: Character[]
  ) {
    this.service = service;
    this.state = new ObservableState<CraftUIState>({
      stage: 'selecting-recipe',
      unlockedRecipes: [],
      lockedRecipes: [],
      selectedRecipe: null,
      materialCheck: null,
      successRate: 0,
      isProcessing: false,
      result: null,
      cursorIndex: 0,
      categoryFilter: null,
      availableOnlyFilter: false,
      showLockedRecipes: false,
      unlockableRecipes: [],
      recentlyUnlockedRecipes: []
    });
    this.events = new EventEmitter<CraftEvents>();
  }
  
  subscribe(listener: (state: CraftUIState) => void): () => void {
    return this.state.subscribe(listener);
  }
  
  on<K extends keyof CraftEvents>(
    event: K,
    listener: (data: CraftEvents[K]) => void
  ): () => void {
    return this.events.on(event, listener);
  }
  
  // ã‚¯ãƒ©ãƒ•ãƒˆé–‹å§‹
  startCrafting(): void {
    const unlockedRecipes = this.service.getUnlockedRecipes(this.gameState);
    const unlockableRecipes = this.service.getUnlockableRecipes(this.gameState, this.party);
    
    // è§£æ”¾å¯èƒ½ãªãƒ¬ã‚·ãƒ”ã‚’è‡ªå‹•è§£æ”¾
    if (unlockableRecipes.length > 0) {
      for (const recipe of unlockableRecipes) {
        this.service.unlockRecipe(recipe.id, this.gameState, 'auto');
      }
      this.events.emit('recipes-auto-unlocked', { recipes: unlockableRecipes });
    }
    
    // å…¨ãƒ¬ã‚·ãƒ”ã‹ã‚‰è§£æ”¾æ¸ˆã¿ä»¥å¤–ã‚’å–å¾—
    const allRecipes = this.service.getAllRecipes();
    const lockedRecipes = allRecipes.filter(r => 
      !this.gameState.unlockedRecipes.has(r.id) && !r.isUnlockedByDefault
    );
    
    this.state.setState({
      stage: 'selecting-recipe',
      unlockedRecipes,
      lockedRecipes,
      selectedRecipe: null,
      materialCheck: null,
      successRate: 0,
      isProcessing: false,
      result: null,
      cursorIndex: 0,
      categoryFilter: null,
      availableOnlyFilter: false,
      showLockedRecipes: false,
      unlockableRecipes: [],
      recentlyUnlockedRecipes: unlockableRecipes
    });
  }
  
  // ãƒ¬ã‚·ãƒ”é¸æŠ
  selectRecipe(recipe: Recipe): void {
    // è§£æ”¾ãƒã‚§ãƒƒã‚¯
    if (!this.gameState.unlockedRecipes.has(recipe.id) && !recipe.isUnlockedByDefault) {
      this.state.setState(prev => ({
        ...prev,
        stage: 'viewing-locked',
        selectedRecipe: recipe
      }));
      return;
    }
    
    // ææ–™ãƒã‚§ãƒƒã‚¯
    const materialCheck = this.service.checkMaterials(recipe, this.inventory);
    
    // æˆåŠŸç‡å–å¾—
    const successRate = this.calculateSuccessRate(recipe);
    
    this.state.setState(prev => ({
      ...prev,
      selectedRecipe: recipe,
      materialCheck: materialCheck as RecipeCheckResult,
      successRate
    }));
    
    this.events.emit('recipe-selected', { recipe });
  }
  
  // æœªè§£æ”¾ãƒ¬ã‚·ãƒ”è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
  toggleShowLockedRecipes(): void {
    this.state.setState(prev => ({
      ...prev,
      showLockedRecipes: !prev.showLockedRecipes
    }));
  }
  
  // ãƒ¬ã‚·ãƒ”æ‰‹å‹•è§£æ”¾ï¼ˆç‰¹å®šæ¡ä»¶ã§ä½¿ç”¨ï¼‰
  unlockRecipe(recipeId: UniqueId, trigger?: string): void {
    const recipe = this.service.getAllRecipes().find(r => r.id === recipeId);
    if (!recipe) return;
    
    this.service.unlockRecipe(recipeId, this.gameState, trigger);
    
    // çŠ¶æ…‹ã‚’æ›´æ–°
    const unlockedRecipes = this.service.getUnlockedRecipes(this.gameState);
    const allRecipes = this.service.getAllRecipes();
    const lockedRecipes = allRecipes.filter(r => 
      !this.gameState.unlockedRecipes.has(r.id) && !r.isUnlockedByDefault
    );
    
    this.state.setState(prev => ({
      ...prev,
      unlockedRecipes,
      lockedRecipes,
      recentlyUnlockedRecipes: [...prev.recentlyUnlockedRecipes, recipe]
    }));
    
    this.events.emit('recipe-unlocked', { recipe, trigger });
  }
  
  // ãƒ•ã‚£ãƒ«ã‚¿è¨­å®š
  setFilter(category: CraftCategory | null, availableOnly: boolean): void {
    this.state.setState(prev => ({
      ...prev,
      categoryFilter: category,
      availableOnlyFilter: availableOnly,
      cursorIndex: 0
    }));
  }
  
  // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã•ã‚ŒãŸãƒ¬ã‚·ãƒ”ã‚’å–å¾—
  getFilteredRecipes(): Recipe[] {
    const currentState = this.state.getState();
    let recipes = currentState.availableRecipes;
    
    // ã‚«ãƒ†ã‚´ãƒªãƒ•ã‚£ãƒ«ã‚¿
    if (currentState.categoryFilter) {
      recipes = recipes.filter(r => r.category === currentState.categoryFilter);
    }
    
    // ä½œæˆå¯èƒ½ãƒ•ã‚£ãƒ«ã‚¿
    if (currentState.availableOnlyFilter) {
      recipes = recipes.filter(r => {
        const check = this.service.checkMaterials(r, this.inventory);
        return check.canCraft;
      });
    }
    
    return recipes;
  }
  
  // ç¢ºèªç”»é¢ã¸
  moveToConfirming(): void {
    this.state.setState(prev => ({
      ...prev,
      stage: 'confirming'
    }));
  }
  
  // åˆæˆå®Ÿè¡Œ
  async synthesize(): Promise<void> {
    const recipe = this.state.getState().selectedRecipe!;
    
    this.state.setState(prev => ({
      ...prev,
      stage: 'synthesizing',
      isProcessing: true
    }));
    
    this.events.emit('synthesis-started', { recipe });
    
    try {
      // åˆæˆå®Ÿè¡Œ
      const result = this.service.synthesize(recipe, this.inventory);
      
      this.state.setState(prev => ({
        ...prev,
        stage: 'completed',
        result: result as SynthesisResult,
        isProcessing: false
      }));
      
      this.events.emit('synthesis-completed', { result: result as SynthesisResult });
    } catch (error) {
      // ã‚¨ãƒ©ãƒ¼å‡¦ç†
      this.state.setState(prev => ({
        ...prev,
        stage: 'selecting-recipe',
        isProcessing: false
      }));
    }
  }
  
  // ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•
  moveCursor(delta: number): void {
    const filteredRecipes = this.getFilteredRecipes();
    const maxIndex = filteredRecipes.length - 1;
    const currentIndex = this.state.getState().cursorIndex;
    
    const newIndex = Math.max(0, Math.min(maxIndex, currentIndex + delta));
    
    this.state.setState(prev => ({
      ...prev,
      cursorIndex: newIndex
    }));
  }
  
  // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  cancel(): void {
    const currentState = this.state.getState();
    
    if (currentState.stage === 'confirming') {
      // ãƒ¬ã‚·ãƒ”é¸æŠã«æˆ»ã‚‹
      this.state.setState(prev => ({
        ...prev,
        stage: 'selecting-recipe'
      }));
    } else {
      // å®Œå…¨ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«
      this.events.emit('cancelled', {});
    }
  }
  
  // æˆåŠŸç‡è¨ˆç®—
  private calculateSuccessRate(recipe: Recipe): number {
    // Serviceã‚’é€šã˜ã¦æˆåŠŸç‡ã‚’è¨ˆç®—
    return recipe.baseSuccessRate || 100;
  }
}
```

### ä½¿ç”¨ä¾‹ï¼ˆReactï¼‰

```typescript
function CraftScreen() {
  const [state, setState] = useState<CraftUIState>();
  const controllerRef = useRef<CraftController>();
  
  useEffect(() => {
    const service = new CraftService(coreEngine);
    const controller = new CraftController(service, inventory);
    controllerRef.current = controller;
    
    const unsubscribe = controller.subscribe(setState);
    
    controller.startCrafting();
    
    return unsubscribe;
  }, []);
  
  if (!state) return <div>Loading...</div>;
  
  return (
    <div className="craft-screen">
      {state.stage === 'selecting-recipe' && (
        <>
          <RecipeFilters
            categoryFilter={state.categoryFilter}
            availableOnlyFilter={state.availableOnlyFilter}
            onFilterChange={(cat, avail) => 
              controllerRef.current?.setFilter(cat, avail)
            }
          />
          
          <RecipeList
            recipes={controllerRef.current?.getFilteredRecipes() || []}
            cursorIndex={state.cursorIndex}
            onSelectRecipe={(recipe) => controllerRef.current?.selectRecipe(recipe)}
          />
          
          {state.selectedRecipe && state.materialCheck && (
            <RecipeDetail
              recipe={state.selectedRecipe}
              materialCheck={state.materialCheck}
              successRate={state.successRate}
              onConfirm={() => controllerRef.current?.moveToConfirming()}
            />
          )}
        </>
      )}
      
      {state.stage === 'confirming' && (
        <ConfirmDialog
          recipe={state.selectedRecipe!}
          onConfirm={() => controllerRef.current?.synthesize()}
          onCancel={() => controllerRef.current?.cancel()}
        />
      )}
      
      {state.stage === 'synthesizing' && (
        <SynthesisAnimation isProcessing={state.isProcessing} />
      )}
      
      {state.stage === 'completed' && state.result && (
        <SynthesisResult result={state.result} />
      )}
    </div>
  );
}
```


