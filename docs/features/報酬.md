# 報酬システム設計

戦闘報酬の処理に関する設計。Core Engine、Service、Headless UIの3層で構成。

## 目次

1. [概要](#概要)
2. [Core Engine層](#core-engine層)
3. [Service層](#service層)
4. [Headless UI層](#headless-ui層)

---

## 概要

### 3層アーキテクチャ

```
┌─────────────────────────────────────┐
│  Headless UI Layer                  │
│  Controller                         │  ← UI状態管理、ユーザー操作
└─────────────────────────────────────┘
              ↓ 委譲
┌─────────────────────────────────────┐
│  Service Layer                      │
│  Service                            │  ← ビジネスロジック
└─────────────────────────────────────┘
              ↓ 委譲
┌─────────────────────────────────────┐
│  Core Engine Layer                  │
│  モジュール                          │  ← 純粋な計算
└─────────────────────────────────────┘
```

---

## Core Engine層

このシステムのCore Engine層の実装は他のモジュールを参照してください。

---

## Service層

---

## 8. RewardService - 戦闘報酬処理

### 概要
戦闘終了後の報酬（経験値、お金、アイテム）の配分とレベルアップ処理を管理。

### 公開インターフェース

```typescript
class RewardService {
  // 報酬配分
  distributeRewards(party: Character[], rewards: BattleRewards): RewardDistributionResult;
  
  // 経験値配分
  distributeExp(party: Character[], totalExp: number): Map<Character, number>;
  
  // レベルアップ処理
  processLevelUps(character: Character, gainedExp: number): LevelUpResult[];
  
  // アイテム追加
  addItems(inventory: Inventory, items: Item[]): InventoryResult;
}
```

### Core Engine 委譲

- `character/growth.distributeExpToParty()` - 経験値配分
- `character/growth.checkLevelUp()` - レベルアップ判定
- `character/growth.calculateStatGrowth()` - ステータス成長計算
- `item/inventory.addItemToInventory()` - アイテム追加

### 実装例

```typescript
class RewardService {
  constructor(
    private coreEngine: CoreEngine,
    private inventoryService: InventoryService
  ) {}
  
  distributeRewards(party: Character[], rewards: BattleRewards): RewardDistributionResult {
    // 経験値配分
    const expDistribution = this.distributeExp(party, rewards.exp);
    
    // レベルアップ処理
    const levelUpResults: Map<Character, LevelUpResult[]> = new Map();
    for (const [character, gainedExp] of expDistribution.entries()) {
      const levelUps = this.processLevelUps(character, gainedExp);
      if (levelUps.length > 0) {
        levelUpResults.set(character, levelUps);
      }
    }
    
    // アイテム追加
    const itemResults = this.addItems(rewards.items);
    
    // お金追加
    // gameState.money += rewards.money; // GameState経由で追加
    
    return {
      expDistribution,
      levelUpResults,
      itemResults,
      totalMoney: rewards.money
    };
  }
  
  distributeExp(party: Character[], totalExp: number): Map<Character, number> {
    // Core Engineで経験値配分を計算
    const distribution = this.coreEngine.distributeExpToParty(party, totalExp);
    
    // 各キャラクターに経験値を加算
    for (const [character, exp] of distribution.entries()) {
      character.currentExp += exp;
    }
    
    return distribution;
  }
  
  processLevelUps(character: Character, gainedExp: number): LevelUpResult[] {
    const results: LevelUpResult[] = [];
    
    // レベルアップ判定を繰り返す
    while (this.coreEngine.checkLevelUp(character)) {
      const previousLevel = character.level;
      const previousStats = { ...character.stats };
      
      // レベルアップ
      character.level++;
      
      // 次のレベルまでの必要経験値を取得
      const expToNext = this.coreEngine.getExpForNextLevel(character.level);
      character.currentExp -= expToNext;
      
      // ステータス成長
      const statGrowth = this.coreEngine.calculateStatGrowth(character, previousLevel);
      character.stats.maxHp += statGrowth.hp;
      character.stats.maxMp += statGrowth.mp;
      character.stats.attack += statGrowth.attack;
      character.stats.defense += statGrowth.defense;
      character.stats.magicAttack += statGrowth.magicAttack;
      character.stats.magicDefense += statGrowth.magicDefense;
      character.stats.speed += statGrowth.speed;
      
      // HP/MP全回復
      character.currentHp = character.stats.maxHp;
      character.currentMp = character.stats.maxMp;
      
      // 習得スキル
      const newSkills = this.coreEngine.getSkillsLearnedAtLevel(character, character.level);
      character.skills.push(...newSkills);
      
      results.push({
        newLevel: character.level,
        statGrowth,
        newSkills
      });
    }
    
    return results;
  }
  
  addItems(items: Item[]): InventoryResult {
    // InventoryServiceに委譲
    const results: InventoryResult[] = [];
    for (const item of items) {
      results.push(this.inventoryService.addItem(item, 1));
    }
    
    return {
      success: results.every(r => r.success),
      addedItems: items
    };
  }
}
```



---

## Headless UI層

---

## 9. RewardController - 報酬受取UI制御

### 状態定義

```typescript
interface RewardUIState {
  // 報酬内容
  rewards: BattleRewards | null;
  
  // 段階
  stage: 'displaying-rewards' | 'distributing-exp' | 'level-ups' | 'completed';
  
  // 経験値配分
  expDistribution: Map<Character, number>;
  
  // レベルアップ
  levelUpQueue: LevelUpResult[];
  currentLevelUp: LevelUpResult | null;
  
  // アニメーション
  isAnimating: boolean;
  animationProgress: number;
  
  // 結果
  finalPartyState: Character[];
}

interface LevelUpResult {
  character: Character;
  oldLevel: number;
  newLevel: number;
  statGains: {
    hp: number;
    mp: number;
    attack: number;
    defense: number;
    magic: number;
    speed: number;
  };
  newSkills: Skill[];
}
```

### コントローラー実装

```typescript
type RewardEvents = {
  'rewards-displayed': { rewards: BattleRewards };
  'exp-distributed': { distribution: Map<Character, number> };
  'level-up': { result: LevelUpResult };
  'all-complete': { party: Character[] };
};

class RewardController {
  private state: ObservableState<RewardUIState>;
  private events: EventEmitter<RewardEvents>;
  private service: RewardService;
  
  constructor(service: RewardService) {
    this.service = service;
    this.state = new ObservableState<RewardUIState>({
      rewards: null,
      stage: 'displaying-rewards',
      expDistribution: new Map(),
      levelUpQueue: [],
      currentLevelUp: null,
      isAnimating: false,
      animationProgress: 0,
      finalPartyState: []
    });
    this.events = new EventEmitter<RewardEvents>();
  }
  
  subscribe(listener: (state: RewardUIState) => void): () => void {
    return this.state.subscribe(listener);
  }
  
  on<K extends keyof RewardEvents>(
    event: K,
    listener: (data: RewardEvents[K]) => void
  ): () => void {
    return this.events.on(event, listener);
  }
  
  // 報酬処理開始
  async processRewards(party: Character[], rewards: BattleRewards): Promise<void> {
    this.state.setState(prev => ({
      ...prev,
      rewards,
      stage: 'displaying-rewards',
      finalPartyState: [...party]
    }));
    
    this.events.emit('rewards-displayed', { rewards });
    
    // 少し待機
    await this.wait(1000);
    
    // 経験値配分
    await this.distributeExp(party, rewards.exp);
  }
  
  // 経験値配分
  private async distributeExp(party: Character[], totalExp: number): Promise<void> {
    this.state.setState(prev => ({
      ...prev,
      stage: 'distributing-exp',
      isAnimating: true
    }));
    
    const distribution = this.service.distributeExp(party, totalExp);
    
    this.state.setState(prev => ({
      ...prev,
      expDistribution: distribution
    }));
    
    this.events.emit('exp-distributed', { distribution });
    
    // アニメーション
    await this.animateExpGain();
    
    // レベルアップチェック
    await this.checkLevelUps(party, distribution);
  }
  
  // 経験値獲得アニメーション
  private async animateExpGain(): Promise<void> {
    for (let i = 0; i <= 100; i += 10) {
      this.state.setState(prev => ({
        ...prev,
        animationProgress: i
      }));
      await this.wait(50);
    }
    
    this.state.setState(prev => ({
      ...prev,
      isAnimating: false,
      animationProgress: 0
    }));
  }
  
  // レベルアップチェック
  private async checkLevelUps(
    party: Character[],
    expDistribution: Map<Character, number>
  ): Promise<void> {
    const levelUpQueue: LevelUpResult[] = [];
    
    for (const [character, exp] of expDistribution.entries()) {
      const levelUps = this.service.processLevelUps(character, exp);
      levelUpQueue.push(...(levelUps as LevelUpResult[]));
    }
    
    if (levelUpQueue.length > 0) {
      this.state.setState(prev => ({
        ...prev,
        stage: 'level-ups',
        levelUpQueue
      }));
      
      await this.displayLevelUps(levelUpQueue);
    } else {
      this.complete();
    }
  }
  
  // レベルアップ表示
  private async displayLevelUps(levelUps: LevelUpResult[]): Promise<void> {
    for (const levelUp of levelUps) {
      this.state.setState(prev => ({
        ...prev,
        currentLevelUp: levelUp
      }));
      
      this.events.emit('level-up', { result: levelUp });
      
      // レベルアップ演出待機
      await this.wait(2000);
    }
    
    this.complete();
  }
  
  // 完了
  private complete(): void {
    const finalParty = this.state.getState().finalPartyState;
    
    this.state.setState(prev => ({
      ...prev,
      stage: 'completed',
      currentLevelUp: null
    }));
    
    this.events.emit('all-complete', { party: finalParty });
  }
  
  // スキップ
  skipAnimations(): void {
    this.complete();
  }
  
  private wait(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```


